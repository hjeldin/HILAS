/**********************************************************************
 *
 * Copyright (c) 2010-2013
 * All rights reserved.
 *
 * Robotics and Mechatronics (RaM) group
 * Faculty of Electrical Engineering, Mathematics and Computer Science
 * University of Twente
 *
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Author(s):
 * Yury Brodskiy, Robert Wilterdink
 *
 * Supervised by: 
 * Jan F. Broenink
 * 
 * The research leading to these results has received funding from the 
 * European Community's Seventh Framework Programme (FP7/2007-2013) 
 * under grant agreement no. FP7-ICT-231940-BRICS (Best Practice in 
 * Robotics).
 * 
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * This software is published under a dual-license: GNU Lesser General 
 * Public License LGPL 2.1 and BSD license. The dual-license implies 
 * that users of this code may choose which terms they prefer.
 *
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above 
 *       copyright notice, this list of conditions and the following 
 *       disclaimer in the documentation and/or other materials 
 *       provided with the distribution.
 *     * Neither the name of the University of Twente nor the names of 
 *       its contributors may be used to endorse or promote products 
 *       derived from this software without specific prior written 
 *       permission.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License LGPL as
 * published by the Free Software Foundation, either version 2.1 of the
 * License, or (at your option) any later version or the BSD license.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License LGPL and the BSD license for more 
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License LGPL and BSD license along with this program.
 *
 **********************************************************************/

/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\OdometryModel.cpp
 *  subm:  OdometryModel
 *  model: motion_stack
 *  expmt: motion_stack
 *  date:  November 1, 2012
 *  time:  4:08:55 pm
 *  user:  Campuslicentie
 *  from:  Universiteit Twente
 *  build: 4.1.4.1
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "OdometryModel.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>

using namespace std;

namespace motion_stack
{

	OdometryModel::OdometryModel(): m_model_config(this)
	{
		using namespace boost;

		setupComputation();
	}

	OdometryModel::~OdometryModel(void)
	{
		/* free memory */
		delete[] C;
		delete[] P;
		delete[] I;
		delete[] V;
		delete[] s;
		delete[] R;
		delete[] M;
		delete[] U;
		delete[] workarray;
	}

  void OdometryModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.001;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 0;
    number_initialvalues = 0;
    number_variables = 137;
    number_states = 0;
    number_rates = 0;
    number_matrices = 37;
    number_unnamed = 159;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[0 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[0 + 1]; /* initial values */
    V = new XXDouble[137 + 1]; /* variables */

    s = new XXDouble[0 + 1]; /* states */
    R = new XXDouble[0 + 1]; /* rates (or new states) */
    M = new XXMatrix[37 + 1]; /* matrices */
    U = new XXDouble[159 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

	bool OdometryModel::loadModelConfiguration(std::string uri)
	{
	  m_model_config.load(uri);
	  return true;
	}

	XXModelConfiguration& OdometryModel::getModelConfiguration()
	{
	  return m_model_config;
	}

  bool OdometryModel::configure()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    

    //INITIAL VALUES
    

    //MATRICES
    	M[0].mat = &V[0];		/* T_base_00 */
	M[0].rows = 6;
	M[0].columns = 1;
	M[1].mat = &V[6];		/* H_base_map */
	M[1].rows = 4;
	M[1].columns = 4;
	M[2].mat = &V[22];		/* H_odom_map */
	M[2].rows = 4;
	M[2].columns = 4;
	M[3].mat = &V[38];		/* H_base_odom */
	M[3].rows = 4;
	M[3].columns = 4;
	M[4].mat = &V[54];		/* R */
	M[4].rows = 3;
	M[4].columns = 3;
	M[5].mat = &V[63];		/* omega */
	M[5].rows = 3;
	M[5].columns = 1;
	M[6].mat = &V[66];		/* v */
	M[6].rows = 3;
	M[6].columns = 1;
	M[7].mat = &V[70];		/* omega_temp */
	M[7].rows = 3;
	M[7].columns = 1;
	M[8].mat = &V[73];		/* H */
	M[8].rows = 4;
	M[8].columns = 4;
	M[9].mat = &V[89];		/* aldo */
	M[9].rows = 4;
	M[9].columns = 4;
	M[10].mat = &V[105];		/* aldoH_odom_map */
	M[10].rows = 4;
	M[10].columns = 4;
	M[11].mat = &V[121];		/* H_base_baseprev */
	M[11].rows = 4;
	M[11].columns = 4;
	M[12].mat = &U[0];		/* U1 */
	M[12].rows = 3;
	M[12].columns = 1;
	M[13].mat = &U[3];		/* U2 */
	M[13].rows = 3;
	M[13].columns = 1;
	M[14].mat = &U[6];		/* U3 */
	M[14].rows = 1;
	M[14].columns = 1;
	M[15].mat = &U[7];		/* U4 */
	M[15].rows = 4;
	M[15].columns = 4;
	M[16].mat = &U[23];		/* U5 */
	M[16].rows = 4;
	M[16].columns = 4;
	M[17].mat = &U[39];		/* U6 */
	M[17].rows = 1;
	M[17].columns = 1;
	M[18].mat = &U[40];		/* U7 */
	M[18].rows = 3;
	M[18].columns = 3;
	M[19].mat = &U[49];		/* U8 */
	M[19].rows = 3;
	M[19].columns = 3;
	M[20].mat = &U[58];		/* U9 */
	M[20].rows = 3;
	M[20].columns = 3;
	M[21].mat = &U[67];		/* U10 */
	M[21].rows = 3;
	M[21].columns = 3;
	M[22].mat = &U[76];		/* U11 */
	M[22].rows = 3;
	M[22].columns = 3;
	M[23].mat = &U[85];		/* U12 */
	M[23].rows = 3;
	M[23].columns = 3;
	M[24].mat = &U[94];		/* U13 */
	M[24].rows = 3;
	M[24].columns = 3;
	M[25].mat = &U[103];		/* U14 */
	M[25].rows = 3;
	M[25].columns = 3;
	M[26].mat = &U[112];		/* U15 */
	M[26].rows = 3;
	M[26].columns = 1;
	M[27].mat = &U[115];		/* U16 */
	M[27].rows = 3;
	M[27].columns = 1;
	M[28].mat = &U[118];		/* U17 */
	M[28].rows = 3;
	M[28].columns = 1;
	M[29].mat = &U[121];		/* U18 */
	M[29].rows = 3;
	M[29].columns = 3;
	M[30].mat = &U[130];		/* U19 */
	M[30].rows = 3;
	M[30].columns = 3;
	M[31].mat = &U[139];		/* U20 */
	M[31].rows = 3;
	M[31].columns = 1;
	M[32].mat = &U[142];		/* U21 */
	M[32].rows = 3;
	M[32].columns = 3;
	M[33].mat = &U[151];		/* U22 */
	M[33].rows = 3;
	M[33].columns = 1;
	M[34].mat = &U[154];		/* U23 */
	M[34].rows = 1;
	M[34].columns = 1;
	M[35].mat = &U[155];		/* U24 */
	M[35].rows = 1;
	M[35].columns = 3;
	M[36].mat = &U[158];		/* U25 */
	M[36].rows = 1;
	M[36].columns = 1;


    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    // overload INITIALIZE_* with values from xml
    std::vector<XVMatrix>& pps = m_model_config.getConfiguration();

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      if( static_cast<unsigned int>(pps[i].storage.rows * pps[i].storage.columns) != pps[i].values.size())
        throw std::out_of_range("" + pps[i].name);

      // Copy to XXData -> double*
      memcpy(pps[i].storage.mat, pps[i].values.data(), pps[i].values.size()*sizeof(double));
    }

    //STATES - do NOT move this line up!
    

    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void OdometryModel::start()
  {
    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void OdometryModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
         and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void OdometryModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  XXDouble OdometryModel::getTime(void)
  {
    return time;
  }

	/* This function calculates the initial equations of the model.
	 * These equations are calculated before anything else
	 */
	inline void OdometryModel::CalculateInitial (void)
	{
				/* H_base_odom = eye (4); */
		XXMatrixEye (&M[3]);

		/* H = eye (4); */
		XXMatrixEye (&M[8]);

		/* aldo = eye (4); */
		XXMatrixEye (&M[9]);

		/* H_base_baseprev = eye (4); */
		XXMatrixEye (&M[11]);

		/* aldoH_odom_map = eye (4); */
		XXMatrixEye (&M[10]);

	}

	/* This function calculates the static equations of the model.
	 * These equations are only dependent from parameters and constants
	 */
	inline void OdometryModel::CalculateStatic (void)
	{
		
	}

	/* This function calculates the input equations of the model.
	 * These equations are dynamic equations that must not change
	 * in calls from the integration method (like random and delay).
	 */
	inline void OdometryModel::CalculateInput (void)
	{
		
	}

	/* This function calculates the dynamic equations of the model.
	 * These equations are called from the integration method
	 * to calculate the new model rates (that are then integrated).
	 */
	inline void OdometryModel::CalculateDynamic (void)
	{
				/* omega = T_base_00[1:3] * sampletime; */
		M[12].mat[0] = M[0].mat[0];
		M[12].mat[1] = M[0].mat[1];
		M[12].mat[2] = M[0].mat[2];
		XXMatrixScalarMul (&M[5], &M[12], step_size);

		/* v = T_base_00[4:6] * sampletime; */
		M[13].mat[0] = M[0].mat[3];
		M[13].mat[1] = M[0].mat[4];
		M[13].mat[2] = M[0].mat[5];
		XXMatrixScalarMul (&M[6], &M[13], step_size);

		/* omega_norm = norm (omega); */
		XXMatrixNorm (&V[69], &M[5]);

		/* if (omega_norm == 0) */
		if (V[69] == 0.0)
		{
			/* H = tilde (T_base_00) + eye (4); */
			XXMatrixTilde (&M[15], &M[0]);
			XXMatrixEye (&M[16]);
			XXMatrixAdd (&M[8], &M[15], &M[16]);
		}
		else
		{
			/* omega_temp = omega / omega_norm; */
			XXMatrixScalarDiv (&M[7], &M[5], V[69]);

			/* R = (eye (3) + skew (omega_temp) * sin (omega_norm)) + (skew (omega_temp) * skew (omega_temp)) * (1 - cos (omega_norm)); */
			XXMatrixEye (&M[19]);
			XXMatrixSkew (&M[21], &M[7]);
			XXMatrixScalarMul (&M[20], &M[21], sin (V[69]));
			XXMatrixAdd (&M[18], &M[19], &M[20]);
			XXMatrixSkew (&M[24], &M[7]);
			XXMatrixSkew (&M[25], &M[7]);
			XXMatrixMul (&M[23], &M[24], &M[25]);
			XXMatrixScalarMul (&M[22], &M[23], (1.0 - cos (V[69])));
			XXMatrixAdd (&M[4], &M[18], &M[22]);

			/* H[1:3,1:3] = R; */
			M[8].mat[0] = M[4].mat[0];
			M[8].mat[1] = M[4].mat[1];
			M[8].mat[2] = M[4].mat[2];
			M[8].mat[4] = M[4].mat[3];
			M[8].mat[5] = M[4].mat[4];
			M[8].mat[6] = M[4].mat[5];
			M[8].mat[8] = M[4].mat[6];
			M[8].mat[9] = M[4].mat[7];
			M[8].mat[10] = M[4].mat[8];

			/* H[1:3,4] = ((eye (3) - R) * (skew (omega) * v) + (transpose (omega) * v) * omega) / omega_norm ^ 2; */
			XXMatrixEye (&M[30]);
			XXMatrixSub (&M[29], &M[30], &M[4]);
			XXMatrixSkew (&M[32], &M[5]);
			XXMatrixMul (&M[31], &M[32], &M[6]);
			XXMatrixMul (&M[28], &M[29], &M[31]);
			XXMatrixTranspose (&M[35], &M[5]);
			XXScalarMatrixMatrixMul (M[34].mat, &M[35], &M[6]);
			XXScalarMatrixMul (&M[33], M[34].mat[0], &M[5]);
			XXMatrixAdd (&M[27], &M[28], &M[33]);
			XXMatrixScalarDiv (&M[26], &M[27], (V[69] * V[69]));
			M[8].mat[3] = M[26].mat[0];
			M[8].mat[7] = M[26].mat[1];
			M[8].mat[11] = M[26].mat[2];

			/* H[4,4] = 1; */
			M[8].mat[15] = 1.0;

			/* H[4,1:3] = 0; */
			M[8].mat[12] = 0.0;
			M[8].mat[13] = 0.0;
			M[8].mat[14] = 0.0;
		}

		/* aldo = H_base_odom * H; */
		XXMatrixMul (&M[9], &M[3], &M[8]);

		/* H_base_odom = aldo; */
		XXMatrixMov (&M[3], &M[9]);

		/* if H_odom_map[4,4] == 1 */
		if (M[2].mat[15] == 1.0)
		{
			/* aldoH_odom_map = H_odom_map; */
			XXMatrixMov (&M[10], &M[2]);
		}

		/* H_base_map = (aldoH_odom_map) * H_base_odom; */
		XXMatrixMul (&M[1], &M[10], &M[3]);

	}

	/* This function calculates the output equations of the model.
	 * These equations are not needed for calculation of the rates
	 * and are kept separate to make the dynamic set of equations smaller.
	 * These dynamic equations are called often more than one time for each
	 * integration step that is taken. This makes model computation much faster.
	 */
	inline void OdometryModel::CalculateOutput (void)
	{
		
			}

	/* This function calculates the final equations of the model.
	 * These equations are calculated after all the calculations
	 * are performed
	 */
	inline void OdometryModel::CalculateFinal (void)
	{
		
	}

	bool OdometryModel::setPeriod(double seconds)
	{
			step_size = seconds;
			return true;
	}

	double OdometryModel::getPeriod()
  {
      return step_size;
  }

}

