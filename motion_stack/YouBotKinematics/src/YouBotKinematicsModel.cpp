/**********************************************************************
 *
 * Copyright (c) 2010-2013
 * All rights reserved.
 *
 * Robotics and Mechatronics (RaM) group
 * Faculty of Electrical Engineering, Mathematics and Computer Science
 * University of Twente
 *
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Author(s):
 * Yury Brodskiy, Robert Wilterdink
 *
 * Supervised by: 
 * Jan F. Broenink
 * 
 * The research leading to these results has received funding from the 
 * European Community's Seventh Framework Programme (FP7/2007-2013) 
 * under grant agreement no. FP7-ICT-231940-BRICS (Best Practice in 
 * Robotics).
 * 
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * This software is published under a dual-license: GNU Lesser General 
 * Public License LGPL 2.1 and BSD license. The dual-license implies 
 * that users of this code may choose which terms they prefer.
 *
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions 
 * are met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above 
 *       copyright notice, this list of conditions and the following 
 *       disclaimer in the documentation and/or other materials 
 *       provided with the distribution.
 *     * Neither the name of the University of Twente nor the names of 
 *       its contributors may be used to endorse or promote products 
 *       derived from this software without specific prior written 
 *       permission.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License LGPL as
 * published by the Free Software Foundation, either version 2.1 of the
 * License, or (at your option) any later version or the BSD license.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License LGPL and the BSD license for more 
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License LGPL and BSD license along with this program.
 *
 **********************************************************************/

/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\YouBotKinematicsModel.cpp
 *  subm:  YouBotKinematicsModel
 *  model: motion_stack
 *  expmt: motion_stack
 *  date:  November 2, 2012
 *  time:  9:43:30 am
 *  user:  Campuslicentie
 *  from:  Universiteit Twente
 *  build: 4.1.4.1
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "YouBotKinematicsModel.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>

using namespace std;

namespace motion_stack
{

	YouBotKinematicsModel::YouBotKinematicsModel(): m_model_config(this)
	{
		using namespace boost;

		setupComputation();
	}

	YouBotKinematicsModel::~YouBotKinematicsModel(void)
	{
		/* free memory */
		delete[] C;
		delete[] P;
		delete[] I;
		delete[] V;
		delete[] s;
		delete[] R;
		delete[] M;
		delete[] U;
		delete[] workarray;
	}

  void YouBotKinematicsModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.001;
    time = 0;
    major = true;

    number_constants = 24;
    number_parameters = 64;
    number_initialvalues = 11;
    number_variables = 621;
    number_states = 11;
    number_rates = 11;
    number_matrices = 131;
    number_unnamed = 528;

    /* the variable arrays */
    C = new XXDouble[24 + 1]; /* constants */
    P = new XXDouble[64 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[11 + 1]; /* initial values */
    V = new XXDouble[621 + 1]; /* variables */

    s = new XXDouble[11 + 1]; /* states */
    R = new XXDouble[11 + 1]; /* rates (or new states) */
    M = new XXMatrix[131 + 1]; /* matrices */
    U = new XXDouble[528 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

	bool YouBotKinematicsModel::loadModelConfiguration(std::string uri)
	{
	  m_model_config.load(uri);
	  return true;
	}

	XXModelConfiguration& YouBotKinematicsModel::getModelConfiguration()
	{
	  return m_model_config;
	}

  bool YouBotKinematicsModel::configure()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    	C[0] = 1.0;		/* CalculateJ\vx */
	C[1] = 0.0;		
	C[2] = 0.0;		
	C[3] = 0.0;		/* CalculateJ\vy */
	C[4] = 1.0;		
	C[5] = 0.0;		
	C[6] = 0.0;		/* CalculateJ\omegaz */
	C[7] = 0.0;		
	C[8] = 1.0;		
	C[9] = 0.0;		/* CalculateJ\omega1 */
	C[10] = 0.0;		
	C[11] = -1.0;		
	C[12] = 0.0;		/* CalculateJ\omega2 */
	C[13] = 1.0;		
	C[14] = 0.0;		
	C[15] = 0.0;		/* CalculateJ\omega3 */
	C[16] = 1.0;		
	C[17] = 0.0;		
	C[18] = 0.0;		/* CalculateJ\omega4 */
	C[19] = 1.0;		
	C[20] = 0.0;		
	C[21] = 0.0;		/* CalculateJ\omega5 */
	C[22] = 0.0;		
	C[23] = -1.0;		


    //PARAMETERS
    	P[0] = 1.0;		/* CalculateJ\InitialJointPos */
	P[1] = 1.0;		
	P[2] = 1.0;		
	P[3] = 1.0;		
	P[4] = 1.0;		
	P[5] = 0.024;		/* CalculateJ\Linkdim */
	P[6] = 0.033;		
	P[7] = 0.0;		
	P[8] = 0.0;		
	P[9] = 0.0;		
	P[10] = 0.0;		
	P[11] = 0.0;		
	P[12] = 0.0;		
	P[13] = 0.0;		
	P[14] = 0.0;		
	P[15] = 0.0;		
	P[16] = 0.0;		
	P[17] = 0.096;		
	P[18] = 0.019;		
	P[19] = 0.155;		
	P[20] = 0.135;		
	P[21] = 0.096;		
	P[22] = 0.034;		
	P[23] = 1.0;		/* CalculateJ\InitialBasePos */
	P[24] = 0.0;		
	P[25] = 0.0;		
	P[26] = 1.0;		
	P[27] = 0.0;		
	P[28] = 1.0;		
	P[29] = 0.0;		
	P[30] = 0.0;		
	P[31] = 0.0;		
	P[32] = 0.0;		
	P[33] = 1.0;		
	P[34] = 0.0;		
	P[35] = 0.0;		
	P[36] = 0.0;		
	P[37] = 0.0;		
	P[38] = 1.0;		
	P[39] = 0.143;		/* CalculateJ\baseoffset */
	P[40] = 0.0;		
	P[41] = 0.046;		
	P[42] = 0.0;		/* DiscreteDifferential\initial */
	P[43] = 0.0;		
	P[44] = 0.0;		
	P[45] = 0.0;		
	P[46] = 0.0;		
	P[47] = 0.0;		
	P[48] = 0.0;		
	P[49] = 0.0;		
	P[50] = 1000.0;		/* EnergyEncodingArm\roundUp */
	P[51] = 100.0;		/* EnergyEncodingArm\MaxCounter */
	P[52] = 1000.0;		/* EnergyEncodingBase\roundUp */
	P[53] = 100.0;		/* EnergyEncodingBase\MaxCounter */
	P[54] = 1000.0;		/* EnergyEncodingSpring\roundUp */
	P[55] = 100.0;		/* EnergyEncodingSpring\MaxCounter */
	P[56] = 1.0;		/* PassivityLayer\EnergyTankBlock\InitialEnergyState {J} */
	P[57] = 3.0;		/* PassivityLayer\Gain\K */
	P[58] = 0.0;		/* PassivityLayer\SETP1\CommunicationTreshold {J} */
	P[59] = 0.1;		/* PassivityLayer\SETP1\SendoutPercent */
	P[60] = 0.0;		/* PassivityLayer\SETP2\CommunicationTreshold {J} */
	P[61] = 0.1;		/* PassivityLayer\SETP2\SendoutPercent */
	P[62] = 0.0;		/* PassivityLayer\SETP3\CommunicationTreshold {J} */
	P[63] = 0.1;		/* PassivityLayer\SETP3\SendoutPercent */


    //INITIAL VALUES
    	I[0] = 0.0;		/* DiscreteDifferential\input_previous_initial */
	I[1] = 0.0;		
	I[2] = 0.0;		
	I[3] = 0.0;		
	I[4] = 0.0;		
	I[5] = 0.0;		
	I[6] = 0.0;		
	I[7] = 0.0;		
	I[8] = 0.0;		/* EnergyEncodingArm\outputCount_previous_initial */
	I[9] = 0.0;		/* EnergyEncodingBase\outputCount_previous_initial */
	I[10] = 0.0;		/* EnergyEncodingSpring\outputCount_previous_initial */


    //MATRICES
    	M[0].mat = &V[1];		/* CalculateJ\controllableJ */
	M[0].rows = 6;
	M[0].columns = 8;
	M[1].mat = &V[49];		/* CalculateJ\Htip0 */
	M[1].rows = 4;
	M[1].columns = 4;
	M[2].mat = &P[0];		/* CalculateJ\InitialJointPos */
	M[2].rows = 5;
	M[2].columns = 1;
	M[3].mat = &P[5];		/* CalculateJ\Linkdim */
	M[3].rows = 3;
	M[3].columns = 6;
	M[4].mat = &P[23];		/* CalculateJ\InitialBasePos */
	M[4].rows = 4;
	M[4].columns = 4;
	M[5].mat = &P[39];		/* CalculateJ\baseoffset */
	M[5].rows = 3;
	M[5].columns = 1;
	M[6].mat = &C[0];		/* CalculateJ\vx */
	M[6].rows = 3;
	M[6].columns = 1;
	M[7].mat = &C[3];		/* CalculateJ\vy */
	M[7].rows = 3;
	M[7].columns = 1;
	M[8].mat = &C[6];		/* CalculateJ\omegaz */
	M[8].rows = 3;
	M[8].columns = 1;
	M[9].mat = &C[9];		/* CalculateJ\omega1 */
	M[9].rows = 3;
	M[9].columns = 1;
	M[10].mat = &C[12];		/* CalculateJ\omega2 */
	M[10].rows = 3;
	M[10].columns = 1;
	M[11].mat = &C[15];		/* CalculateJ\omega3 */
	M[11].rows = 3;
	M[11].columns = 1;
	M[12].mat = &C[18];		/* CalculateJ\omega4 */
	M[12].rows = 3;
	M[12].columns = 1;
	M[13].mat = &C[21];		/* CalculateJ\omega5 */
	M[13].rows = 3;
	M[13].columns = 1;
	M[14].mat = &V[65];		/* CalculateJ\uTrzrefref */
	M[14].rows = 6;
	M[14].columns = 1;
	M[15].mat = &V[71];		/* CalculateJ\uTryrefref */
	M[15].rows = 6;
	M[15].columns = 1;
	M[16].mat = &V[77];		/* CalculateJ\uTrxrefref */
	M[16].rows = 6;
	M[16].columns = 1;
	M[17].mat = &V[83];		/* CalculateJ\uTr1refref */
	M[17].rows = 6;
	M[17].columns = 1;
	M[18].mat = &V[89];		/* CalculateJ\uTr211 */
	M[18].rows = 6;
	M[18].columns = 1;
	M[19].mat = &V[95];		/* CalculateJ\uTr322 */
	M[19].rows = 6;
	M[19].columns = 1;
	M[20].mat = &V[101];		/* CalculateJ\uTr433 */
	M[20].rows = 6;
	M[20].columns = 1;
	M[21].mat = &V[107];		/* CalculateJ\uTr544 */
	M[21].rows = 6;
	M[21].columns = 1;
	M[22].mat = &V[113];		/* CalculateJ\R21 */
	M[22].rows = 3;
	M[22].columns = 3;
	M[23].mat = &V[122];		/* CalculateJ\R32 */
	M[23].rows = 3;
	M[23].columns = 3;
	M[24].mat = &V[131];		/* CalculateJ\R43 */
	M[24].rows = 3;
	M[24].columns = 3;
	M[25].mat = &V[140];		/* CalculateJ\R54 */
	M[25].rows = 3;
	M[25].columns = 3;
	M[26].mat = &V[149];		/* CalculateJ\Rtip5 */
	M[26].rows = 3;
	M[26].columns = 3;
	M[27].mat = &V[158];		/* CalculateJ\p21 */
	M[27].rows = 3;
	M[27].columns = 1;
	M[28].mat = &V[161];		/* CalculateJ\p32 */
	M[28].rows = 3;
	M[28].columns = 1;
	M[29].mat = &V[164];		/* CalculateJ\p43 */
	M[29].rows = 3;
	M[29].columns = 1;
	M[30].mat = &V[167];		/* CalculateJ\p54 */
	M[30].rows = 3;
	M[30].columns = 1;
	M[31].mat = &V[170];		/* CalculateJ\ptip5 */
	M[31].rows = 3;
	M[31].columns = 1;
	M[32].mat = &V[173];		/* CalculateJ\H21 */
	M[32].rows = 4;
	M[32].columns = 4;
	M[33].mat = &V[189];		/* CalculateJ\H32 */
	M[33].rows = 4;
	M[33].columns = 4;
	M[34].mat = &V[205];		/* CalculateJ\H43 */
	M[34].rows = 4;
	M[34].columns = 4;
	M[35].mat = &V[221];		/* CalculateJ\H54 */
	M[35].rows = 4;
	M[35].columns = 4;
	M[36].mat = &V[237];		/* CalculateJ\Htip5 */
	M[36].rows = 4;
	M[36].columns = 4;
	M[37].mat = &V[253];		/* CalculateJ\H10 */
	M[37].rows = 4;
	M[37].columns = 4;
	M[38].mat = &V[269];		/* CalculateJ\H20 */
	M[38].rows = 4;
	M[38].columns = 4;
	M[39].mat = &V[285];		/* CalculateJ\H30 */
	M[39].rows = 4;
	M[39].columns = 4;
	M[40].mat = &V[301];		/* CalculateJ\H40 */
	M[40].rows = 4;
	M[40].columns = 4;
	M[41].mat = &V[317];		/* CalculateJ\H50 */
	M[41].rows = 4;
	M[41].columns = 4;
	M[42].mat = &V[333];		/* CalculateJ\Href0 */
	M[42].rows = 4;
	M[42].columns = 4;
	M[43].mat = &V[349];		/* CalculateJ\H1ref */
	M[43].rows = 4;
	M[43].columns = 4;
	M[44].mat = &V[365];		/* CalculateJ\R1ref */
	M[44].rows = 3;
	M[44].columns = 3;
	M[45].mat = &V[374];		/* CalculateJ\p1ref */
	M[45].rows = 3;
	M[45].columns = 1;
	M[46].mat = &V[377];		/* CalculateJ\base_offset_H */
	M[46].rows = 4;
	M[46].columns = 4;
	M[47].mat = &V[393];		/* CalculateJ\initialq */
	M[47].rows = 8;
	M[47].columns = 1;
	M[48].mat = &V[401];		/* CalculateJ\Rz */
	M[48].rows = 3;
	M[48].columns = 3;
	M[49].mat = &V[410];		/* CmdDemux\arm_torque */
	M[49].rows = 5;
	M[49].columns = 1;
	M[50].mat = &V[415];		/* CmdDemux\W_base_00 */
	M[50].rows = 6;
	M[50].columns = 1;
	M[51].mat = &V[421];		/* DiscreteDifferential\output */
	M[51].rows = 8;
	M[51].columns = 1;
	M[52].mat = &P[42];		/* DiscreteDifferential\initial */
	M[52].rows = 8;
	M[52].columns = 1;
	M[53].mat = &V[429];		/* DiscreteDifferential\initial_input */
	M[53].rows = 8;
	M[53].columns = 1;
	M[54].mat = &V[438];		/* EnergyEncodingArm\inputMessage */
	M[54].rows = 2;
	M[54].columns = 1;
	M[55].mat = &V[441];		/* EnergyEncodingArm\outputMessage */
	M[55].rows = 2;
	M[55].columns = 1;
	M[56].mat = &V[446];		/* EnergyEncodingBase\inputMessage */
	M[56].rows = 2;
	M[56].columns = 1;
	M[57].mat = &V[449];		/* EnergyEncodingBase\outputMessage */
	M[57].rows = 2;
	M[57].columns = 1;
	M[58].mat = &V[454];		/* EnergyEncodingSpring\inputMessage */
	M[58].rows = 2;
	M[58].columns = 1;
	M[59].mat = &V[457];		/* EnergyEncodingSpring\outputMessage */
	M[59].rows = 2;
	M[59].columns = 1;
	M[60].mat = &V[462];		/* HToAngles\H_vp_0 */
	M[60].rows = 4;
	M[60].columns = 4;
	M[61].mat = &V[478];		/* HToAngles\pose */
	M[61].rows = 3;
	M[61].columns = 1;
	M[62].mat = &V[481];		/* HToAngles\H_vp_base */
	M[62].rows = 4;
	M[62].columns = 4;
	M[63].mat = &V[499];		/* HToAngles\norm_omega */
	M[63].rows = 3;
	M[63].columns = 1;
	M[64].mat = &V[502];		/* HToAngles\omega */
	M[64].rows = 3;
	M[64].columns = 1;
	M[65].mat = &V[515];		/* StateMux\arm_angles */
	M[65].rows = 5;
	M[65].columns = 1;
	M[66].mat = &V[520];		/* StateMux\measured_angles */
	M[66].rows = 8;
	M[66].columns = 1;
	M[67].mat = &V[528];		/* TF\joints_e */
	M[67].rows = 8;
	M[67].columns = 1;
	M[68].mat = &V[536];		/* TF\tip_e */
	M[68].rows = 6;
	M[68].columns = 1;
	M[69].mat = &V[542];		/* TF\tip_f */
	M[69].rows = 6;
	M[69].columns = 1;
	M[70].mat = &V[548];		/* H_base_0 */
	M[70].rows = 4;
	M[70].columns = 4;
	M[71].mat = &V[565];		/* output_energy_arm */
	M[71].rows = 2;
	M[71].columns = 1;
	M[72].mat = &V[567];		/* input_energy_base */
	M[72].rows = 2;
	M[72].columns = 1;
	M[73].mat = &V[569];		/* output_energy_base */
	M[73].rows = 2;
	M[73].columns = 1;
	M[74].mat = &V[571];		/* T_tooltip_00 */
	M[74].rows = 6;
	M[74].columns = 1;
	M[75].mat = &V[577];		/* torques_cmd */
	M[75].rows = 5;
	M[75].columns = 1;
	M[76].mat = &V[582];		/* W_base_00 */
	M[76].rows = 6;
	M[76].columns = 1;
	M[77].mat = &V[588];		/* input_energy_spring */
	M[77].rows = 2;
	M[77].columns = 1;
	M[78].mat = &V[590];		/* output_energy_spring */
	M[78].rows = 2;
	M[78].columns = 1;
	M[79].mat = &V[592];		/* angles_measured */
	M[79].rows = 5;
	M[79].columns = 1;
	M[80].mat = &V[597];		/* input_energy_arm */
	M[80].rows = 2;
	M[80].columns = 1;
	M[81].mat = &V[599];		/* W_tooltip_00 */
	M[81].rows = 6;
	M[81].columns = 1;
	M[82].mat = &V[605];		/* H_tooltip_0 */
	M[82].rows = 4;
	M[82].columns = 4;
	M[83].mat = &R[0];		/* DiscreteDifferential\input */
	M[83].rows = 8;
	M[83].columns = 1;
	M[84].mat = &s[0];		/* DiscreteDifferential\input_previous */
	M[84].rows = 8;
	M[84].columns = 1;
	M[85].mat = &I[0];		/* DiscreteDifferential\input_previous_initial */
	M[85].rows = 8;
	M[85].columns = 1;
	M[86].mat = &U[0];		/* U1 */
	M[86].rows = 3;
	M[86].columns = 3;
	M[87].mat = &U[9];		/* U2 */
	M[87].rows = 3;
	M[87].columns = 1;
	M[88].mat = &U[12];		/* U3 */
	M[88].rows = 3;
	M[88].columns = 3;
	M[89].mat = &U[21];		/* U4 */
	M[89].rows = 3;
	M[89].columns = 1;
	M[90].mat = &U[24];		/* U5 */
	M[90].rows = 3;
	M[90].columns = 1;
	M[91].mat = &U[27];		/* U6 */
	M[91].rows = 3;
	M[91].columns = 3;
	M[92].mat = &U[36];		/* U7 */
	M[92].rows = 3;
	M[92].columns = 1;
	M[93].mat = &U[39];		/* U8 */
	M[93].rows = 3;
	M[93].columns = 1;
	M[94].mat = &U[42];		/* U9 */
	M[94].rows = 3;
	M[94].columns = 3;
	M[95].mat = &U[51];		/* U10 */
	M[95].rows = 3;
	M[95].columns = 1;
	M[96].mat = &U[54];		/* U11 */
	M[96].rows = 3;
	M[96].columns = 1;
	M[97].mat = &U[57];		/* U12 */
	M[97].rows = 3;
	M[97].columns = 3;
	M[98].mat = &U[66];		/* U13 */
	M[98].rows = 3;
	M[98].columns = 1;
	M[99].mat = &U[69];		/* U14 */
	M[99].rows = 3;
	M[99].columns = 1;
	M[100].mat = &U[72];		/* U15 */
	M[100].rows = 3;
	M[100].columns = 3;
	M[101].mat = &U[81];		/* U16 */
	M[101].rows = 3;
	M[101].columns = 1;
	M[102].mat = &U[84];		/* U17 */
	M[102].rows = 1;
	M[102].columns = 1;
	M[103].mat = &U[85];		/* U18 */
	M[103].rows = 3;
	M[103].columns = 3;
	M[104].mat = &U[94];		/* U19 */
	M[104].rows = 1;
	M[104].columns = 1;
	M[105].mat = &U[95];		/* U20 */
	M[105].rows = 1;
	M[105].columns = 1;
	M[106].mat = &U[96];		/* U21 */
	M[106].rows = 3;
	M[106].columns = 1;
	M[107].mat = &U[99];		/* U22 */
	M[107].rows = 4;
	M[107].columns = 4;
	M[108].mat = &U[115];		/* U23 */
	M[108].rows = 3;
	M[108].columns = 1;
	M[109].mat = &U[118];		/* U24 */
	M[109].rows = 6;
	M[109].columns = 1;
	M[110].mat = &U[124];		/* U25 */
	M[110].rows = 6;
	M[110].columns = 6;
	M[111].mat = &U[160];		/* U26 */
	M[111].rows = 6;
	M[111].columns = 1;
	M[112].mat = &U[166];		/* U27 */
	M[112].rows = 6;
	M[112].columns = 6;
	M[113].mat = &U[202];		/* U28 */
	M[113].rows = 6;
	M[113].columns = 1;
	M[114].mat = &U[208];		/* U29 */
	M[114].rows = 6;
	M[114].columns = 6;
	M[115].mat = &U[244];		/* U30 */
	M[115].rows = 6;
	M[115].columns = 1;
	M[116].mat = &U[250];		/* U31 */
	M[116].rows = 6;
	M[116].columns = 6;
	M[117].mat = &U[286];		/* U32 */
	M[117].rows = 6;
	M[117].columns = 1;
	M[118].mat = &U[292];		/* U33 */
	M[118].rows = 6;
	M[118].columns = 6;
	M[119].mat = &U[328];		/* U34 */
	M[119].rows = 6;
	M[119].columns = 1;
	M[120].mat = &U[334];		/* U35 */
	M[120].rows = 6;
	M[120].columns = 6;
	M[121].mat = &U[370];		/* U36 */
	M[121].rows = 6;
	M[121].columns = 1;
	M[122].mat = &U[376];		/* U37 */
	M[122].rows = 6;
	M[122].columns = 6;
	M[123].mat = &U[412];		/* U38 */
	M[123].rows = 6;
	M[123].columns = 1;
	M[124].mat = &U[418];		/* U39 */
	M[124].rows = 6;
	M[124].columns = 6;
	M[125].mat = &U[454];		/* U40 */
	M[125].rows = 1;
	M[125].columns = 1;
	M[126].mat = &U[455];		/* U41 */
	M[126].rows = 8;
	M[126].columns = 1;
	M[127].mat = &U[463];		/* U42 */
	M[127].rows = 1;
	M[127].columns = 1;
	M[128].mat = &U[464];		/* U43 */
	M[128].rows = 8;
	M[128].columns = 1;
	M[129].mat = &U[472];		/* U44 */
	M[129].rows = 8;
	M[129].columns = 1;
	M[130].mat = &U[480];		/* U45 */
	M[130].rows = 8;
	M[130].columns = 6;


    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    // overload INITIALIZE_* with values from xml
    std::vector<XVMatrix>& pps = m_model_config.getConfiguration();

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      if( static_cast<unsigned int>(pps[i].storage.rows * pps[i].storage.columns) != pps[i].values.size())
        throw std::out_of_range("" + pps[i].name);

      // Copy to XXData -> double*
      memcpy(pps[i].storage.mat, pps[i].values.data(), pps[i].values.size()*sizeof(double));
    }

    //STATES - do NOT move this line up!
    	s[0] = I[0];		/* DiscreteDifferential\input_previous */
	s[1] = I[1];
	s[2] = I[2];
	s[3] = I[3];
	s[4] = I[4];
	s[5] = I[5];
	s[6] = I[6];
	s[7] = I[7];
	s[8] = I[8];		/* EnergyEncodingArm\outputCount_previous */
	s[9] = I[9];		/* EnergyEncodingBase\outputCount_previous */
	s[10] = I[10];		/* EnergyEncodingSpring\outputCount_previous */


    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void YouBotKinematicsModel::start()
  {
    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void YouBotKinematicsModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
         and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void YouBotKinematicsModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  XXDouble YouBotKinematicsModel::getTime(void)
  {
    return time;
  }

	/* This function calculates the initial equations of the model.
	 * These equations are calculated before anything else
	 */
	inline void YouBotKinematicsModel::CalculateInitial (void)
	{
				/* CalculateJ\initialq = [0; 0; 0; CalculateJ\InitialJointPos[1]; CalculateJ\InitialJointPos[2]; CalculateJ\InitialJointPos[3]; CalculateJ\InitialJointPos[4]; CalculateJ\InitialJointPos[5]]; */
		M[47].mat[0] = 0.0;
		M[47].mat[1] = 0.0;
		M[47].mat[2] = 0.0;
		M[47].mat[3] = M[2].mat[0];
		M[47].mat[4] = M[2].mat[1];
		M[47].mat[5] = M[2].mat[2];
		M[47].mat[6] = M[2].mat[3];
		M[47].mat[7] = M[2].mat[4];

		/* DiscreteDifferential\initialized = 0.0; */
		V[437] = XXFALSE;

		/* EnergyEncodingArm\inputSum = 0; */
		V[443] = 0.0;

		/* EnergyEncodingArm\outputSum = 0; */
		V[445] = 0.0;

		/* EnergyEncodingBase\inputSum = 0; */
		V[451] = 0.0;

		/* EnergyEncodingBase\outputSum = 0; */
		V[453] = 0.0;

		/* EnergyEncodingSpring\inputSum = 0; */
		V[459] = 0.0;

		/* EnergyEncodingSpring\outputSum = 0; */
		V[461] = 0.0;

		/* PassivityLayer\EnergyTankBlock\EnergyState = PassivityLayer\EnergyTankBlock\InitialEnergyState; */
		V[506] = P[56];

		/* PassivityLayer\SETP1\outputPackage = 0; */
		V[510] = 0.0;

		/* PassivityLayer\SETP1\energyQuanta = 0; */
		V[509] = 0.0;

		/* PassivityLayer\SETP2\outputPackage = 0; */
		V[512] = 0.0;

		/* PassivityLayer\SETP2\energyQuanta = 0; */
		V[511] = 0.0;

		/* PassivityLayer\SETP3\outputPackage = 0; */
		V[514] = 0.0;

		/* PassivityLayer\SETP3\energyQuanta = 0; */
		V[513] = 0.0;

	}

	/* This function calculates the static equations of the model.
	 * These equations are only dependent from parameters and constants
	 */
	inline void YouBotKinematicsModel::CalculateStatic (void)
	{
			/* CalculateJ\base_offset_H = homogeneous (eye (3), CalculateJ\baseoffset); */
	XXMatrixEye (&M[86]);
	XXMatrixHomogeneous (&M[46], &M[86], &M[5]);

	/* CalculateJ\p1ref = CalculateJ\Linkdim[1:3,1]; */
	M[45].mat[0] = M[3].mat[0];
	M[45].mat[1] = M[3].mat[6];
	M[45].mat[2] = M[3].mat[12];

	/* CalculateJ\p21 = CalculateJ\Linkdim[1:3,2]; */
	M[27].mat[0] = M[3].mat[1];
	M[27].mat[1] = M[3].mat[7];
	M[27].mat[2] = M[3].mat[13];

	/* CalculateJ\p32 = CalculateJ\Linkdim[1:3,3]; */
	M[28].mat[0] = M[3].mat[2];
	M[28].mat[1] = M[3].mat[8];
	M[28].mat[2] = M[3].mat[14];

	/* CalculateJ\p43 = CalculateJ\Linkdim[1:3,4]; */
	M[29].mat[0] = M[3].mat[3];
	M[29].mat[1] = M[3].mat[9];
	M[29].mat[2] = M[3].mat[15];

	/* CalculateJ\p54 = CalculateJ\Linkdim[1:3,5]; */
	M[30].mat[0] = M[3].mat[4];
	M[30].mat[1] = M[3].mat[10];
	M[30].mat[2] = M[3].mat[16];

	/* CalculateJ\Rtip5 = eye (3); */
	XXMatrixEye (&M[26]);

	/* CalculateJ\ptip5 = CalculateJ\Linkdim[1:3,6]; */
	M[31].mat[0] = M[3].mat[5];
	M[31].mat[1] = M[3].mat[11];
	M[31].mat[2] = M[3].mat[17];

	/* CalculateJ\Htip5 = homogeneous (CalculateJ\Rtip5, CalculateJ\ptip5); */
	XXMatrixHomogeneous (&M[36], &M[26], &M[31]);

	/* CalculateJ\uTrzrefref[1:3] = CalculateJ\omegaz; */
	M[14].mat[0] = M[8].mat[0];
	M[14].mat[1] = M[8].mat[1];
	M[14].mat[2] = M[8].mat[2];

	/* CalculateJ\uTrzrefref[4:6] = 0; */
	M[14].mat[3] = 0.0;
	M[14].mat[4] = 0.0;
	M[14].mat[5] = 0.0;

	/* CalculateJ\uTryrefref[1:3] = 0; */
	M[15].mat[0] = 0.0;
	M[15].mat[1] = 0.0;
	M[15].mat[2] = 0.0;

	/* CalculateJ\uTryrefref[4:6] = CalculateJ\vy; */
	M[15].mat[3] = M[7].mat[0];
	M[15].mat[4] = M[7].mat[1];
	M[15].mat[5] = M[7].mat[2];

	/* CalculateJ\uTrxrefref[1:3] = 0; */
	M[16].mat[0] = 0.0;
	M[16].mat[1] = 0.0;
	M[16].mat[2] = 0.0;

	/* CalculateJ\uTrxrefref[4:6] = CalculateJ\vx; */
	M[16].mat[3] = M[6].mat[0];
	M[16].mat[4] = M[6].mat[1];
	M[16].mat[5] = M[6].mat[2];

	/* CalculateJ\uTr1refref[1:3] = CalculateJ\omega1; */
	M[17].mat[0] = M[9].mat[0];
	M[17].mat[1] = M[9].mat[1];
	M[17].mat[2] = M[9].mat[2];

	/* CalculateJ\uTr1refref[4:6] = skew (CalculateJ\Linkdim[1:3,1]) * CalculateJ\omega1; */
	M[89].mat[0] = M[3].mat[0];
	M[89].mat[1] = M[3].mat[6];
	M[89].mat[2] = M[3].mat[12];
	XXMatrixSkew (&M[88], &M[89]);
	XXMatrixMul (&M[87], &M[88], &M[9]);
	M[17].mat[3] = M[87].mat[0];
	M[17].mat[4] = M[87].mat[1];
	M[17].mat[5] = M[87].mat[2];

	/* CalculateJ\uTr211[1:3] = CalculateJ\omega2; */
	M[18].mat[0] = M[10].mat[0];
	M[18].mat[1] = M[10].mat[1];
	M[18].mat[2] = M[10].mat[2];

	/* CalculateJ\uTr211[4:6] = skew (CalculateJ\Linkdim[1:3,2]) * CalculateJ\omega2; */
	M[92].mat[0] = M[3].mat[1];
	M[92].mat[1] = M[3].mat[7];
	M[92].mat[2] = M[3].mat[13];
	XXMatrixSkew (&M[91], &M[92]);
	XXMatrixMul (&M[90], &M[91], &M[10]);
	M[18].mat[3] = M[90].mat[0];
	M[18].mat[4] = M[90].mat[1];
	M[18].mat[5] = M[90].mat[2];

	/* CalculateJ\uTr322[1:3] = CalculateJ\omega3; */
	M[19].mat[0] = M[11].mat[0];
	M[19].mat[1] = M[11].mat[1];
	M[19].mat[2] = M[11].mat[2];

	/* CalculateJ\uTr322[4:6] = skew (CalculateJ\Linkdim[1:3,3]) * CalculateJ\omega3; */
	M[95].mat[0] = M[3].mat[2];
	M[95].mat[1] = M[3].mat[8];
	M[95].mat[2] = M[3].mat[14];
	XXMatrixSkew (&M[94], &M[95]);
	XXMatrixMul (&M[93], &M[94], &M[11]);
	M[19].mat[3] = M[93].mat[0];
	M[19].mat[4] = M[93].mat[1];
	M[19].mat[5] = M[93].mat[2];

	/* CalculateJ\uTr433[1:3] = CalculateJ\omega4; */
	M[20].mat[0] = M[12].mat[0];
	M[20].mat[1] = M[12].mat[1];
	M[20].mat[2] = M[12].mat[2];

	/* CalculateJ\uTr433[4:6] = skew (CalculateJ\Linkdim[1:3,4]) * CalculateJ\omega4; */
	M[98].mat[0] = M[3].mat[3];
	M[98].mat[1] = M[3].mat[9];
	M[98].mat[2] = M[3].mat[15];
	XXMatrixSkew (&M[97], &M[98]);
	XXMatrixMul (&M[96], &M[97], &M[12]);
	M[20].mat[3] = M[96].mat[0];
	M[20].mat[4] = M[96].mat[1];
	M[20].mat[5] = M[96].mat[2];

	/* CalculateJ\uTr544[1:3] = CalculateJ\omega5; */
	M[21].mat[0] = M[13].mat[0];
	M[21].mat[1] = M[13].mat[1];
	M[21].mat[2] = M[13].mat[2];

	/* CalculateJ\uTr544[4:6] = skew (CalculateJ\Linkdim[1:3,5]) * CalculateJ\omega5; */
	M[101].mat[0] = M[3].mat[4];
	M[101].mat[1] = M[3].mat[10];
	M[101].mat[2] = M[3].mat[16];
	XXMatrixSkew (&M[100], &M[101]);
	XXMatrixMul (&M[99], &M[100], &M[13]);
	M[21].mat[3] = M[99].mat[0];
	M[21].mat[4] = M[99].mat[1];
	M[21].mat[5] = M[99].mat[2];

	}

	/* This function calculates the input equations of the model.
	 * These equations are dynamic equations that must not change
	 * in calls from the integration method (like random and delay).
	 */
	inline void YouBotKinematicsModel::CalculateInput (void)
	{
		
	}

	/* This function calculates the dynamic equations of the model.
	 * These equations are called from the integration method
	 * to calculate the new model rates (that are then integrated).
	 */
	inline void YouBotKinematicsModel::CalculateDynamic (void)
	{
			/* EnergyEncodingBase\inputMessage = input_energy_base; */
	XXMatrixMov (&M[56], &M[72]);

	/* EnergyEncodingSpring\inputMessage = input_energy_spring; */
	XXMatrixMov (&M[58], &M[77]);

	/* StateMux\arm_angles = angles_measured; */
	XXMatrixMov (&M[65], &M[79]);

	/* EnergyEncodingArm\inputMessage = input_energy_arm; */
	XXMatrixMov (&M[54], &M[80]);

	/* TF\tip_e = W_tooltip_00; */
	XXMatrixMov (&M[68], &M[81]);

		/* if (EnergyEncodingArm\inputMessage[1] + 0.1 * EnergyEncodingArm\roundUp) < EnergyEncodingArm\inputSum */
		if ((M[54].mat[0] + 0.1 * P[50]) < V[443])
		{
			/* EnergyEncodingArm\inputDiff = (EnergyEncodingArm\roundUp + EnergyEncodingArm\inputMessage[1]) - EnergyEncodingArm\inputSum; */
			V[444] = (P[50] + M[54].mat[0]) - V[443];
		}
		else
		{
			/* EnergyEncodingArm\inputDiff = EnergyEncodingArm\inputMessage[1] - EnergyEncodingArm\inputSum; */
			V[444] = M[54].mat[0] - V[443];
		}

		/* EnergyEncodingArm\inputSum = (EnergyEncodingArm\inputSum + EnergyEncodingArm\inputDiff) mod EnergyEncodingArm\roundUp; */
		V[443] = XXIntegerModulo ((V[443] + V[444]), P[50]);

		/* EnergyEncodingArm\inputEnergy = EnergyEncodingArm\inputDiff; */
		V[440] = V[444];

		/* EnergyEncodingArm\outputCount = (EnergyEncodingArm\outputCount_previous + 1) mod EnergyEncodingArm\MaxCounter; */
		R[8] = XXIntegerModulo ((s[8] + 1.0), P[51]);

		/* EnergyEncodingArm\outputSum = (EnergyEncodingArm\outputSum + PassivityLayer\SETP1\outputPackage) mod EnergyEncodingArm\roundUp; */
		V[445] = XXIntegerModulo ((V[445] + V[510]), P[50]);

		/* EnergyEncodingArm\outputMessage[1] = EnergyEncodingArm\outputSum; */
		M[55].mat[0] = V[445];

		/* EnergyEncodingArm\outputMessage[2] = EnergyEncodingArm\outputCount; */
		M[55].mat[1] = R[8];

		/* if (EnergyEncodingBase\inputMessage[1] + 0.1 * EnergyEncodingBase\roundUp) < EnergyEncodingBase\inputSum */
		if ((M[56].mat[0] + 0.1 * P[52]) < V[451])
		{
			/* EnergyEncodingBase\inputDiff = (EnergyEncodingBase\roundUp + EnergyEncodingBase\inputMessage[1]) - EnergyEncodingBase\inputSum; */
			V[452] = (P[52] + M[56].mat[0]) - V[451];
		}
		else
		{
			/* EnergyEncodingBase\inputDiff = EnergyEncodingBase\inputMessage[1] - EnergyEncodingBase\inputSum; */
			V[452] = M[56].mat[0] - V[451];
		}

		/* EnergyEncodingBase\inputSum = (EnergyEncodingBase\inputSum + EnergyEncodingBase\inputDiff) mod EnergyEncodingBase\roundUp; */
		V[451] = XXIntegerModulo ((V[451] + V[452]), P[52]);

		/* EnergyEncodingBase\inputEnergy = EnergyEncodingBase\inputDiff; */
		V[448] = V[452];

		/* EnergyEncodingBase\outputCount = (EnergyEncodingBase\outputCount_previous + 1) mod EnergyEncodingBase\MaxCounter; */
		R[9] = XXIntegerModulo ((s[9] + 1.0), P[53]);

		/* EnergyEncodingBase\outputSum = (EnergyEncodingBase\outputSum + PassivityLayer\SETP2\outputPackage) mod EnergyEncodingBase\roundUp; */
		V[453] = XXIntegerModulo ((V[453] + V[512]), P[52]);

		/* EnergyEncodingBase\outputMessage[1] = EnergyEncodingBase\outputSum; */
		M[57].mat[0] = V[453];

		/* EnergyEncodingBase\outputMessage[2] = EnergyEncodingBase\outputCount; */
		M[57].mat[1] = R[9];

		/* if (EnergyEncodingSpring\inputMessage[1] + 0.1 * EnergyEncodingSpring\roundUp) < EnergyEncodingSpring\inputSum */
		if ((M[58].mat[0] + 0.1 * P[54]) < V[459])
		{
			/* EnergyEncodingSpring\inputDiff = (EnergyEncodingSpring\roundUp + EnergyEncodingSpring\inputMessage[1]) - EnergyEncodingSpring\inputSum; */
			V[460] = (P[54] + M[58].mat[0]) - V[459];
		}
		else
		{
			/* EnergyEncodingSpring\inputDiff = EnergyEncodingSpring\inputMessage[1] - EnergyEncodingSpring\inputSum; */
			V[460] = M[58].mat[0] - V[459];
		}

		/* EnergyEncodingSpring\inputSum = (EnergyEncodingSpring\inputSum + EnergyEncodingSpring\inputDiff) mod EnergyEncodingSpring\roundUp; */
		V[459] = XXIntegerModulo ((V[459] + V[460]), P[54]);

		/* EnergyEncodingSpring\inputEnergy = EnergyEncodingSpring\inputDiff; */
		V[456] = V[460];

		/* EnergyEncodingSpring\outputCount = (EnergyEncodingSpring\outputCount_previous + 1) mod EnergyEncodingSpring\MaxCounter; */
		R[10] = XXIntegerModulo ((s[10] + 1.0), P[55]);

		/* EnergyEncodingSpring\outputSum = (EnergyEncodingSpring\outputSum + PassivityLayer\SETP3\outputPackage) mod EnergyEncodingSpring\roundUp; */
		V[461] = XXIntegerModulo ((V[461] + V[514]), P[54]);

		/* EnergyEncodingSpring\outputMessage[1] = EnergyEncodingSpring\outputSum; */
		M[59].mat[0] = V[461];

		/* EnergyEncodingSpring\outputMessage[2] = EnergyEncodingSpring\outputCount; */
		M[59].mat[1] = R[10];

		/* HToAngles\H_vp_base = HToAngles\H_vp_0; */
		XXMatrixMov (&M[62], &M[60]);

		/* HToAngles\aldo = (trace (HToAngles\H_vp_base[1:3,1:3]) - 1) / 2; */
		M[103].mat[0] = M[62].mat[0];
		M[103].mat[1] = M[62].mat[1];
		M[103].mat[2] = M[62].mat[2];
		M[103].mat[3] = M[62].mat[4];
		M[103].mat[4] = M[62].mat[5];
		M[103].mat[5] = M[62].mat[6];
		M[103].mat[6] = M[62].mat[8];
		M[103].mat[7] = M[62].mat[9];
		M[103].mat[8] = M[62].mat[10];
		M[102].mat[0] = XXMatrixTrace (&M[103]);
		V[497] = (XXMatrixTrace (&M[103]) - 1.0) / 2.0;

		/* if (HToAngles\aldo < -1) */
		if (V[497] < -1.0)
		{
			/* HToAngles\aldo = -1; */
			V[497] = -1.0;
		}

		/* if (HToAngles\aldo > 1) */
		if (V[497] > 1.0)
		{
			/* HToAngles\aldo = 1; */
			V[497] = 1.0;
		}

		/* HToAngles\theta = arccos (HToAngles\aldo); */
		V[498] = acos (V[497]);

		/* if (HToAngles\theta == 0) */
		if (V[498] == 0.0)
		{
			/* HToAngles\norm_omega = 0; */
			XXMatrixScalarMov (&M[63], 0.0);
		}
		else
		{
			/* HToAngles\norm_omega = (1 / (2 * sin (HToAngles\theta))) * [HToAngles\H_vp_base[3,2] - HToAngles\H_vp_base[2,3]; HToAngles\H_vp_base[1,3] - HToAngles\H_vp_base[3,1]; HToAngles\H_vp_base[2,1] - HToAngles\H_vp_base[1,2]]; */
			M[106].mat[0] = M[62].mat[9] - M[62].mat[6];
			M[106].mat[1] = M[62].mat[2] - M[62].mat[8];
			M[106].mat[2] = M[62].mat[4] - M[62].mat[1];
			XXScalarMatrixMul (&M[63], (1.0 / (2.0 * sin (V[498]))), &M[106]);
		}

		/* HToAngles\omega = HToAngles\theta * HToAngles\norm_omega; */
		XXScalarMatrixMul (&M[64], V[498], &M[63]);

		/* HToAngles\pose[1] = HToAngles\omega[3]; */
		M[61].mat[0] = M[64].mat[2];

		/* HToAngles\pose[2] = HToAngles\H_vp_base[1,4]; */
		M[61].mat[1] = M[62].mat[3];

		/* HToAngles\pose[3] = HToAngles\H_vp_base[2,4]; */
		M[61].mat[2] = M[62].mat[7];

	/* StateMux\measured_angles[4:8] = StateMux\arm_angles; */
	M[66].mat[3] = M[65].mat[0];
	M[66].mat[4] = M[65].mat[1];
	M[66].mat[5] = M[65].mat[2];
	M[66].mat[6] = M[65].mat[3];
	M[66].mat[7] = M[65].mat[4];

	/* output_energy_arm = EnergyEncodingArm\outputMessage; */
	XXMatrixMov (&M[71], &M[55]);

	/* output_energy_base = EnergyEncodingBase\outputMessage; */
	XXMatrixMov (&M[73], &M[57]);

	/* output_energy_spring = EnergyEncodingSpring\outputMessage; */
	XXMatrixMov (&M[78], &M[59]);

		/* PassivityLayer\EnergyTankBlock\EnergyState = PassivityLayer\EnergyTankBlock\EnergyState + PassivityLayer\PlusMinus1\output; */
		V[506] = V[506] + V[508];

		/* PassivityLayer\EnergyTankBlock\energyState = PassivityLayer\EnergyTankBlock\EnergyState; */
		V[505] = V[506];

	/* StateMux\measured_angles[1:3] = HToAngles\pose; */
	M[66].mat[0] = M[61].mat[0];
	M[66].mat[1] = M[61].mat[1];
	M[66].mat[2] = M[61].mat[2];

	/* EnergyTank = PassivityLayer\EnergyTankBlock\energyState; */
	V[564] = V[505];

	/* DiscreteDifferential\input = StateMux\measured_angles; */
	XXMatrixMov (&M[83], &M[66]);

	/* CalculateJ\Rz = [cos (StateMux\measured_angles[1]), -sin (StateMux\measured_angles[1]), 0; sin (StateMux\measured_angles[1]), cos (StateMux\measured_angles[1]), 0; 0, 0, 1]; */
	M[48].mat[0] = cos (M[66].mat[0]);
	M[48].mat[1] = -(sin (M[66].mat[0]));
	M[48].mat[2] = 0.0;
	M[48].mat[3] = sin (M[66].mat[0]);
	M[48].mat[4] = cos (M[66].mat[0]);
	M[48].mat[5] = 0.0;
	M[48].mat[6] = 0.0;
	M[48].mat[7] = 0.0;
	M[48].mat[8] = 1.0;

	/* CalculateJ\Href0 = homogeneous (CalculateJ\Rz, [StateMux\measured_angles[2]; StateMux\measured_angles[3]; 0]) * CalculateJ\base_offset_H; */
	M[108].mat[0] = M[66].mat[1];
	M[108].mat[1] = M[66].mat[2];
	M[108].mat[2] = 0.0;
	XXMatrixHomogeneous (&M[107], &M[48], &M[108]);
	XXMatrixMul (&M[42], &M[107], &M[46]);

	/* CalculateJ\R1ref = [cos (-StateMux\measured_angles[4]), -sin (-StateMux\measured_angles[4]), 0; sin (-StateMux\measured_angles[4]), cos (-StateMux\measured_angles[4]), 0; 0, 0, 1]; */
	M[44].mat[0] = cos (-M[66].mat[3]);
	M[44].mat[1] = -(sin (-M[66].mat[3]));
	M[44].mat[2] = 0.0;
	M[44].mat[3] = sin (-M[66].mat[3]);
	M[44].mat[4] = cos (-M[66].mat[3]);
	M[44].mat[5] = 0.0;
	M[44].mat[6] = 0.0;
	M[44].mat[7] = 0.0;
	M[44].mat[8] = 1.0;

	/* CalculateJ\H1ref = homogeneous (CalculateJ\R1ref, CalculateJ\p1ref); */
	XXMatrixHomogeneous (&M[43], &M[44], &M[45]);

	/* CalculateJ\R21 = [cos (StateMux\measured_angles[5]), 0, sin (StateMux\measured_angles[5]); 0, 1, 0; -sin (StateMux\measured_angles[5]), 0, cos (StateMux\measured_angles[5])]; */
	M[22].mat[0] = cos (M[66].mat[4]);
	M[22].mat[1] = 0.0;
	M[22].mat[2] = sin (M[66].mat[4]);
	M[22].mat[3] = 0.0;
	M[22].mat[4] = 1.0;
	M[22].mat[5] = 0.0;
	M[22].mat[6] = -(sin (M[66].mat[4]));
	M[22].mat[7] = 0.0;
	M[22].mat[8] = cos (M[66].mat[4]);

	/* CalculateJ\H21 = homogeneous (CalculateJ\R21, CalculateJ\p21); */
	XXMatrixHomogeneous (&M[32], &M[22], &M[27]);

	/* CalculateJ\R32 = [cos (StateMux\measured_angles[6]), 0, sin (StateMux\measured_angles[6]); 0, 1, 0; -sin (StateMux\measured_angles[6]), 0, cos (StateMux\measured_angles[6])]; */
	M[23].mat[0] = cos (M[66].mat[5]);
	M[23].mat[1] = 0.0;
	M[23].mat[2] = sin (M[66].mat[5]);
	M[23].mat[3] = 0.0;
	M[23].mat[4] = 1.0;
	M[23].mat[5] = 0.0;
	M[23].mat[6] = -(sin (M[66].mat[5]));
	M[23].mat[7] = 0.0;
	M[23].mat[8] = cos (M[66].mat[5]);

	/* CalculateJ\H32 = homogeneous (CalculateJ\R32, CalculateJ\p32); */
	XXMatrixHomogeneous (&M[33], &M[23], &M[28]);

	/* CalculateJ\R43 = [cos (StateMux\measured_angles[7]), 0, sin (StateMux\measured_angles[7]); 0, 1, 0; -sin (StateMux\measured_angles[7]), 0, cos (StateMux\measured_angles[7])]; */
	M[24].mat[0] = cos (M[66].mat[6]);
	M[24].mat[1] = 0.0;
	M[24].mat[2] = sin (M[66].mat[6]);
	M[24].mat[3] = 0.0;
	M[24].mat[4] = 1.0;
	M[24].mat[5] = 0.0;
	M[24].mat[6] = -(sin (M[66].mat[6]));
	M[24].mat[7] = 0.0;
	M[24].mat[8] = cos (M[66].mat[6]);

	/* CalculateJ\H43 = homogeneous (CalculateJ\R43, CalculateJ\p43); */
	XXMatrixHomogeneous (&M[34], &M[24], &M[29]);

	/* CalculateJ\R54 = [cos (-StateMux\measured_angles[8]), -sin (-StateMux\measured_angles[8]), 0; sin (-StateMux\measured_angles[8]), cos (-StateMux\measured_angles[8]), 0; 0, 0, 1]; */
	M[25].mat[0] = cos (-M[66].mat[7]);
	M[25].mat[1] = -(sin (-M[66].mat[7]));
	M[25].mat[2] = 0.0;
	M[25].mat[3] = sin (-M[66].mat[7]);
	M[25].mat[4] = cos (-M[66].mat[7]);
	M[25].mat[5] = 0.0;
	M[25].mat[6] = 0.0;
	M[25].mat[7] = 0.0;
	M[25].mat[8] = 1.0;

	/* CalculateJ\H54 = homogeneous (CalculateJ\R54, CalculateJ\p54); */
	XXMatrixHomogeneous (&M[35], &M[25], &M[30]);

	/* CalculateJ\H10 = CalculateJ\Href0 * CalculateJ\H1ref; */
	XXMatrixMul (&M[37], &M[42], &M[43]);

	/* CalculateJ\H20 = CalculateJ\H10 * CalculateJ\H21; */
	XXMatrixMul (&M[38], &M[37], &M[32]);

	/* CalculateJ\H30 = CalculateJ\H20 * CalculateJ\H32; */
	XXMatrixMul (&M[39], &M[38], &M[33]);

	/* CalculateJ\H40 = CalculateJ\H30 * CalculateJ\H43; */
	XXMatrixMul (&M[40], &M[39], &M[34]);

	/* CalculateJ\H50 = CalculateJ\H40 * CalculateJ\H54; */
	XXMatrixMul (&M[41], &M[40], &M[35]);

	/* CalculateJ\Htip0 = CalculateJ\H50 * CalculateJ\Htip5; */
	XXMatrixMul (&M[1], &M[41], &M[36]);

	/* CalculateJ\controllableJ[1:6,1] = Adjoint (CalculateJ\Href0) * CalculateJ\uTrzrefref; */
	XXMatrixAdjoint (&M[110], &M[42]);
	XXMatrixMul (&M[109], &M[110], &M[14]);
	M[0].mat[0] = M[109].mat[0];
	M[0].mat[8] = M[109].mat[1];
	M[0].mat[16] = M[109].mat[2];
	M[0].mat[24] = M[109].mat[3];
	M[0].mat[32] = M[109].mat[4];
	M[0].mat[40] = M[109].mat[5];

	/* CalculateJ\controllableJ[1:6,3] = Adjoint (CalculateJ\Href0) * CalculateJ\uTryrefref; */
	XXMatrixAdjoint (&M[112], &M[42]);
	XXMatrixMul (&M[111], &M[112], &M[15]);
	M[0].mat[2] = M[111].mat[0];
	M[0].mat[10] = M[111].mat[1];
	M[0].mat[18] = M[111].mat[2];
	M[0].mat[26] = M[111].mat[3];
	M[0].mat[34] = M[111].mat[4];
	M[0].mat[42] = M[111].mat[5];

	/* CalculateJ\controllableJ[1:6,2] = Adjoint (CalculateJ\Href0) * CalculateJ\uTrxrefref; */
	XXMatrixAdjoint (&M[114], &M[42]);
	XXMatrixMul (&M[113], &M[114], &M[16]);
	M[0].mat[1] = M[113].mat[0];
	M[0].mat[9] = M[113].mat[1];
	M[0].mat[17] = M[113].mat[2];
	M[0].mat[25] = M[113].mat[3];
	M[0].mat[33] = M[113].mat[4];
	M[0].mat[41] = M[113].mat[5];

	/* CalculateJ\controllableJ[1:6,4] = Adjoint (CalculateJ\Href0) * CalculateJ\uTr1refref; */
	XXMatrixAdjoint (&M[116], &M[42]);
	XXMatrixMul (&M[115], &M[116], &M[17]);
	M[0].mat[3] = M[115].mat[0];
	M[0].mat[11] = M[115].mat[1];
	M[0].mat[19] = M[115].mat[2];
	M[0].mat[27] = M[115].mat[3];
	M[0].mat[35] = M[115].mat[4];
	M[0].mat[43] = M[115].mat[5];

	/* CalculateJ\controllableJ[1:6,5] = Adjoint (CalculateJ\H10) * CalculateJ\uTr211; */
	XXMatrixAdjoint (&M[118], &M[37]);
	XXMatrixMul (&M[117], &M[118], &M[18]);
	M[0].mat[4] = M[117].mat[0];
	M[0].mat[12] = M[117].mat[1];
	M[0].mat[20] = M[117].mat[2];
	M[0].mat[28] = M[117].mat[3];
	M[0].mat[36] = M[117].mat[4];
	M[0].mat[44] = M[117].mat[5];

	/* CalculateJ\controllableJ[1:6,6] = Adjoint (CalculateJ\H20) * CalculateJ\uTr322; */
	XXMatrixAdjoint (&M[120], &M[38]);
	XXMatrixMul (&M[119], &M[120], &M[19]);
	M[0].mat[5] = M[119].mat[0];
	M[0].mat[13] = M[119].mat[1];
	M[0].mat[21] = M[119].mat[2];
	M[0].mat[29] = M[119].mat[3];
	M[0].mat[37] = M[119].mat[4];
	M[0].mat[45] = M[119].mat[5];

	/* CalculateJ\controllableJ[1:6,7] = Adjoint (CalculateJ\H30) * CalculateJ\uTr433; */
	XXMatrixAdjoint (&M[122], &M[39]);
	XXMatrixMul (&M[121], &M[122], &M[20]);
	M[0].mat[6] = M[121].mat[0];
	M[0].mat[14] = M[121].mat[1];
	M[0].mat[22] = M[121].mat[2];
	M[0].mat[30] = M[121].mat[3];
	M[0].mat[38] = M[121].mat[4];
	M[0].mat[46] = M[121].mat[5];

	/* CalculateJ\controllableJ[1:6,8] = Adjoint (CalculateJ\H40) * CalculateJ\uTr544; */
	XXMatrixAdjoint (&M[124], &M[40]);
	XXMatrixMul (&M[123], &M[124], &M[21]);
	M[0].mat[7] = M[123].mat[0];
	M[0].mat[15] = M[123].mat[1];
	M[0].mat[23] = M[123].mat[2];
	M[0].mat[31] = M[123].mat[3];
	M[0].mat[39] = M[123].mat[4];
	M[0].mat[47] = M[123].mat[5];

	/* if notDiscreteDifferential\initialized */
	if (!V[437])
	{
		/* DiscreteDifferential\initial_input = DiscreteDifferential\initial - DiscreteDifferential\input / sampletime; */
		XXMatrixScalarDiv (&M[126], &M[83], step_size);
		XXMatrixSub (&M[53], &M[52], &M[126]);

		/* DiscreteDifferential\initialized = 1.0; */
		V[437] = XXTRUE;
	}
	else
	{
		/* DiscreteDifferential\initial_input = 0; */
		XXMatrixScalarMov (&M[53], 0.0);
	}

	/* DiscreteDifferential\output = (DiscreteDifferential\input - DiscreteDifferential\input_previous) / sampletime + DiscreteDifferential\initial_input; */
	XXMatrixSub (&M[129], &M[83], &M[84]);
	XXMatrixScalarDiv (&M[128], &M[129], step_size);
	XXMatrixAdd (&M[51], &M[128], &M[53]);

	/* PassivityLayer\Gain\output = PassivityLayer\EnergyTankBlock\energyState / 3; */
	V[507] = V[505] / 3.0;

	/* H_tooltip_0 = CalculateJ\Htip0; */
	XXMatrixMov (&M[82], &M[1]);

	/* TF\joints_e = transpose (CalculateJ\controllableJ) * TF\tip_e; */
	XXMatrixTranspose (&M[130], &M[0]);
	XXMatrixMul (&M[67], &M[130], &M[68]);

	/* TF\tip_f = (CalculateJ\controllableJ) * DiscreteDifferential\output; */
	XXMatrixMul (&M[69], &M[0], &M[51]);

		/* if PassivityLayer\SETP1\CommunicationTreshold > PassivityLayer\Gain\output */
		if (P[58] > V[507])
		{
			/* PassivityLayer\SETP1\outputPackage = 0; */
			V[510] = 0.0;

			/* PassivityLayer\SETP1\energyQuanta = EnergyEncodingArm\inputEnergy; */
			V[509] = V[440];
		}
		else
		{
			/* PassivityLayer\SETP1\outputPackage = -(PassivityLayer\SETP1\CommunicationTreshold - PassivityLayer\Gain\output) * PassivityLayer\SETP1\SendoutPercent; */
			V[510] = -(P[58] - V[507]) * P[59];

			/* PassivityLayer\SETP1\energyQuanta = EnergyEncodingArm\inputEnergy - PassivityLayer\SETP1\outputPackage; */
			V[509] = V[440] - V[510];
		}

		/* if PassivityLayer\SETP2\CommunicationTreshold > PassivityLayer\Gain\output */
		if (P[60] > V[507])
		{
			/* PassivityLayer\SETP2\outputPackage = 0; */
			V[512] = 0.0;

			/* PassivityLayer\SETP2\energyQuanta = EnergyEncodingBase\inputEnergy; */
			V[511] = V[448];
		}
		else
		{
			/* PassivityLayer\SETP2\outputPackage = -(PassivityLayer\SETP2\CommunicationTreshold - PassivityLayer\Gain\output) * PassivityLayer\SETP2\SendoutPercent; */
			V[512] = -(P[60] - V[507]) * P[61];

			/* PassivityLayer\SETP2\energyQuanta = EnergyEncodingBase\inputEnergy - PassivityLayer\SETP2\outputPackage; */
			V[511] = V[448] - V[512];
		}

		/* if PassivityLayer\SETP3\CommunicationTreshold > PassivityLayer\Gain\output */
		if (P[62] > V[507])
		{
			/* PassivityLayer\SETP3\outputPackage = 0; */
			V[514] = 0.0;

			/* PassivityLayer\SETP3\energyQuanta = EnergyEncodingSpring\inputEnergy; */
			V[513] = V[456];
		}
		else
		{
			/* PassivityLayer\SETP3\outputPackage = -(PassivityLayer\SETP3\CommunicationTreshold - PassivityLayer\Gain\output) * PassivityLayer\SETP3\SendoutPercent; */
			V[514] = -(P[62] - V[507]) * P[63];

			/* PassivityLayer\SETP3\energyQuanta = EnergyEncodingSpring\inputEnergy - PassivityLayer\SETP3\outputPackage; */
			V[513] = V[456] - V[514];
		}

	/* T_tooltip_00 = TF\tip_f; */
	XXMatrixMov (&M[74], &M[69]);

	/* CmdDemux\W_base_00 = [0; 0; TF\joints_e[1]; TF\joints_e[2]; TF\joints_e[3]; 0]; */
	M[50].mat[0] = 0.0;
	M[50].mat[1] = 0.0;
	M[50].mat[2] = M[67].mat[0];
	M[50].mat[3] = M[67].mat[1];
	M[50].mat[4] = M[67].mat[2];
	M[50].mat[5] = 0.0;

	/* CmdDemux\arm_torque = TF\joints_e[4:8]; */
	M[49].mat[0] = M[67].mat[3];
	M[49].mat[1] = M[67].mat[4];
	M[49].mat[2] = M[67].mat[5];
	M[49].mat[3] = M[67].mat[6];
	M[49].mat[4] = M[67].mat[7];

	/* torques_cmd = CmdDemux\arm_torque; */
	XXMatrixMov (&M[75], &M[49]);

	/* W_base_00 = CmdDemux\W_base_00; */
	XXMatrixMov (&M[76], &M[50]);

	}

	/* This function calculates the output equations of the model.
	 * These equations are not needed for calculation of the rates
	 * and are kept separate to make the dynamic set of equations smaller.
	 * These dynamic equations are called often more than one time for each
	 * integration step that is taken. This makes model computation much faster.
	 */
	inline void YouBotKinematicsModel::CalculateOutput (void)
	{
			/* HToAngles\H_vp_0 = H_base_0; */
	XXMatrixMov (&M[60], &M[70]);

	/* PassivityLayer\PlusMinus1\output = (PassivityLayer\SETP3\energyQuanta + PassivityLayer\SETP2\energyQuanta) + PassivityLayer\SETP1\energyQuanta; */
	V[508] = (V[513] + V[511]) + V[509];

	/* AntiBug\aldo = EnergyEncodingArm\inputEnergy + TF\tip_f[1]; */
	V[0] = V[440] + M[69].mat[0];

			}

	/* This function calculates the final equations of the model.
	 * These equations are calculated after all the calculations
	 * are performed
	 */
	inline void YouBotKinematicsModel::CalculateFinal (void)
	{
		
	}

	bool YouBotKinematicsModel::setPeriod(double seconds)
	{
			step_size = seconds;
			return true;
	}

	double YouBotKinematicsModel::getPeriod()
  {
      return step_size;
  }

}

