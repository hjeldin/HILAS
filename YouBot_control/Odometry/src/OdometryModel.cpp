/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\OdometryModel.cpp
 *  subm:  OdometryModel
 *  model: motion_stack
 *  expmt: motion_stack
 *  date:  August 6, 2012
 *  time:  4:55:26 pm
 *  user:  Campuslicentie
 *  from:  Universiteit Twente
 *  build: 4.1.2.4
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "OdometryModel.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>

using namespace std;

namespace motion_stack
{

	OdometryModel::OdometryModel(): m_model_config(this)
	{
		using namespace boost;

		setupComputation();
	}

	OdometryModel::~OdometryModel(void)
	{
		/* free memory */
		delete[] C;
		delete[] P;
		delete[] I;
		delete[] V;
		delete[] s;
		delete[] R;
		delete[] M;
		delete[] U;
		delete[] workarray;
	}

  void OdometryModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.001;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 0;
    number_initialvalues = 0;
    number_variables = 73;
    number_states = 0;
    number_rates = 0;
    number_matrices = 32;
    number_unnamed = 158;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[0 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[0 + 1]; /* initial values */
    V = new XXDouble[73 + 1]; /* variables */

    s = new XXDouble[0 + 1]; /* states */
    R = new XXDouble[0 + 1]; /* rates (or new states) */
    M = new XXMatrix[32 + 1]; /* matrices */
    U = new XXDouble[158 + 1]; /* unnamed */
    workarray = new XXDouble[0 + 1];
  }

	bool OdometryModel::loadModelConfiguration(std::string uri)
	{
	  m_model_config.load(uri);
	  return true;
	}

	XXModelConfiguration& OdometryModel::getModelConfiguration()
	{
	  return m_model_config;
	}

  bool OdometryModel::configure()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    

    //INITIAL VALUES
    

    //MATRICES
    	M[0].mat = &V[0];		/* T */
	M[0].rows = 6;
	M[0].columns = 1;
	M[1].mat = &V[6];		/* H_base_0 */
	M[1].rows = 4;
	M[1].columns = 4;
	M[2].mat = &V[22];		/* R */
	M[2].rows = 3;
	M[2].columns = 3;
	M[3].mat = &V[31];		/* omega */
	M[3].rows = 3;
	M[3].columns = 1;
	M[4].mat = &V[34];		/* v */
	M[4].rows = 3;
	M[4].columns = 1;
	M[5].mat = &V[38];		/* omega_temp */
	M[5].rows = 3;
	M[5].columns = 1;
	M[6].mat = &V[41];		/* H */
	M[6].rows = 4;
	M[6].columns = 4;
	M[7].mat = &V[57];		/* Hbase0 */
	M[7].rows = 4;
	M[7].columns = 4;
	M[8].mat = &U[0];		/* U1 */
	M[8].rows = 3;
	M[8].columns = 1;
	M[9].mat = &U[3];		/* U2 */
	M[9].rows = 3;
	M[9].columns = 1;
	M[10].mat = &U[6];		/* U3 */
	M[10].rows = 1;
	M[10].columns = 1;
	M[11].mat = &U[7];		/* U4 */
	M[11].rows = 4;
	M[11].columns = 4;
	M[12].mat = &U[23];		/* U5 */
	M[12].rows = 4;
	M[12].columns = 4;
	M[13].mat = &U[39];		/* U6 */
	M[13].rows = 1;
	M[13].columns = 1;
	M[14].mat = &U[40];		/* U7 */
	M[14].rows = 3;
	M[14].columns = 3;
	M[15].mat = &U[49];		/* U8 */
	M[15].rows = 3;
	M[15].columns = 3;
	M[16].mat = &U[58];		/* U9 */
	M[16].rows = 3;
	M[16].columns = 3;
	M[17].mat = &U[67];		/* U10 */
	M[17].rows = 3;
	M[17].columns = 3;
	M[18].mat = &U[76];		/* U11 */
	M[18].rows = 3;
	M[18].columns = 3;
	M[19].mat = &U[85];		/* U12 */
	M[19].rows = 3;
	M[19].columns = 3;
	M[20].mat = &U[94];		/* U13 */
	M[20].rows = 3;
	M[20].columns = 3;
	M[21].mat = &U[103];		/* U14 */
	M[21].rows = 3;
	M[21].columns = 3;
	M[22].mat = &U[112];		/* U15 */
	M[22].rows = 3;
	M[22].columns = 1;
	M[23].mat = &U[115];		/* U16 */
	M[23].rows = 3;
	M[23].columns = 1;
	M[24].mat = &U[118];		/* U17 */
	M[24].rows = 3;
	M[24].columns = 1;
	M[25].mat = &U[121];		/* U18 */
	M[25].rows = 3;
	M[25].columns = 3;
	M[26].mat = &U[130];		/* U19 */
	M[26].rows = 3;
	M[26].columns = 3;
	M[27].mat = &U[139];		/* U20 */
	M[27].rows = 3;
	M[27].columns = 1;
	M[28].mat = &U[142];		/* U21 */
	M[28].rows = 3;
	M[28].columns = 3;
	M[29].mat = &U[151];		/* U22 */
	M[29].rows = 3;
	M[29].columns = 1;
	M[30].mat = &U[154];		/* U23 */
	M[30].rows = 1;
	M[30].columns = 1;
	M[31].mat = &U[155];		/* U24 */
	M[31].rows = 1;
	M[31].columns = 3;


    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    // overload INITIALIZE_* with values from xml
    std::vector<XVMatrix>& pps = m_model_config.getConfiguration();

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      if( static_cast<unsigned int>(pps[i].storage.rows * pps[i].storage.columns) != pps[i].values.size())
        throw std::out_of_range("" + pps[i].name);

      // Copy to XXData -> double*
      memcpy(pps[i].storage.mat, pps[i].values.data(), pps[i].values.size()*sizeof(double));
    }

    //STATES - do NOT move this line up!
    

    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void OdometryModel::start()
  {
    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void OdometryModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
         and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void OdometryModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  XXDouble OdometryModel::getTime(void)
  {
    return time;
  }

	/* This function calculates the initial equations of the model.
	 * These equations are calculated before anything else
	 */
	inline void OdometryModel::CalculateInitial (void)
	{
				/* H_base_0 = eye (4); */
		XXMatrixEye (&M[1]);

		/* H = eye (4); */
		XXMatrixEye (&M[6]);

		/* Hbase0 = eye (4); */
		XXMatrixEye (&M[7]);

	}

	/* This function calculates the static equations of the model.
	 * These equations are only dependent from parameters and constants
	 */
	inline void OdometryModel::CalculateStatic (void)
	{
		
	}

	/* This function calculates the input equations of the model.
	 * These equations are dynamic equations that must not change
	 * in calls from the integration method (like random and delay).
	 */
	inline void OdometryModel::CalculateInput (void)
	{
		
	}

	/* This function calculates the dynamic equations of the model.
	 * These equations are called from the integration method
	 * to calculate the new model rates (that are then integrated).
	 */
	inline void OdometryModel::CalculateDynamic (void)
	{
				/* omega = T[1:3] * sampletime; */
		M[8].mat[0] = M[0].mat[0];
		M[8].mat[1] = M[0].mat[1];
		M[8].mat[2] = M[0].mat[2];
		XXMatrixScalarMul (&M[3], &M[8], step_size);

		/* v = T[4:6] * sampletime; */
		M[9].mat[0] = M[0].mat[3];
		M[9].mat[1] = M[0].mat[4];
		M[9].mat[2] = M[0].mat[5];
		XXMatrixScalarMul (&M[4], &M[9], step_size);

		/* omega_norm = norm (omega); */
		XXMatrixNorm (&V[37], &M[3]);

		/* if (omega_norm == 0) */
		if (V[37] == 0.0)
		{
			/* H = tilde (T) + eye (4); */
			XXMatrixTilde (&M[11], &M[0]);
			XXMatrixEye (&M[12]);
			XXMatrixAdd (&M[6], &M[11], &M[12]);
		}
		else
		{
			/* omega_temp = omega / omega_norm; */
			XXMatrixScalarDiv (&M[5], &M[3], V[37]);

			/* R = (eye (3) + skew (omega_temp) * sin (omega_norm)) + (skew (omega_temp) * skew (omega_temp)) * (1 - cos (omega_norm)); */
			XXMatrixEye (&M[15]);
			XXMatrixSkew (&M[17], &M[5]);
			XXMatrixScalarMul (&M[16], &M[17], sin (V[37]));
			XXMatrixAdd (&M[14], &M[15], &M[16]);
			XXMatrixSkew (&M[20], &M[5]);
			XXMatrixSkew (&M[21], &M[5]);
			XXMatrixMul (&M[19], &M[20], &M[21]);
			XXMatrixScalarMul (&M[18], &M[19], (1.0 - cos (V[37])));
			XXMatrixAdd (&M[2], &M[14], &M[18]);

			/* H[1:3,1:3] = R; */
			M[6].mat[0] = M[2].mat[0];
			M[6].mat[1] = M[2].mat[1];
			M[6].mat[2] = M[2].mat[2];
			M[6].mat[4] = M[2].mat[3];
			M[6].mat[5] = M[2].mat[4];
			M[6].mat[6] = M[2].mat[5];
			M[6].mat[8] = M[2].mat[6];
			M[6].mat[9] = M[2].mat[7];
			M[6].mat[10] = M[2].mat[8];

			/* H[1:3,4] = ((eye (3) - R) * (skew (omega) * v) + (transpose (omega) * v) * omega) / omega_norm ^ 2; */
			XXMatrixEye (&M[26]);
			XXMatrixSub (&M[25], &M[26], &M[2]);
			XXMatrixSkew (&M[28], &M[3]);
			XXMatrixMul (&M[27], &M[28], &M[4]);
			XXMatrixMul (&M[24], &M[25], &M[27]);
			XXMatrixTranspose (&M[31], &M[3]);
			XXScalarMatrixMatrixMul (M[30].mat, &M[31], &M[4]);
			XXScalarMatrixMul (&M[29], M[30].mat[0], &M[3]);
			XXMatrixAdd (&M[23], &M[24], &M[29]);
			XXMatrixScalarDiv (&M[22], &M[23], (V[37] * V[37]));
			M[6].mat[3] = M[22].mat[0];
			M[6].mat[7] = M[22].mat[1];
			M[6].mat[11] = M[22].mat[2];

			/* H[4,4] = 1; */
			M[6].mat[15] = 1.0;

			/* H[4,1:3] = 0; */
			M[6].mat[12] = 0.0;
			M[6].mat[13] = 0.0;
			M[6].mat[14] = 0.0;
		}

		/* H_base_0 = Hbase0 * H; */
		XXMatrixMul (&M[1], &M[7], &M[6]);

		/* Hbase0 = H_base_0; */
		XXMatrixMov (&M[7], &M[1]);

	}

	/* This function calculates the output equations of the model.
	 * These equations are not needed for calculation of the rates
	 * and are kept separate to make the dynamic set of equations smaller.
	 * These dynamic equations are called often more than one time for each
	 * integration step that is taken. This makes model computation much faster.
	 */
	inline void OdometryModel::CalculateOutput (void)
	{
		
			}

	/* This function calculates the final equations of the model.
	 * These equations are calculated after all the calculations
	 * are performed
	 */
	inline void OdometryModel::CalculateFinal (void)
	{
		
	}

	bool OdometryModel::setPeriod(double seconds)
	{
			step_size = seconds;
			return true;
	}

	double OdometryModel::getPeriod()
  {
      return step_size;
  }

}

