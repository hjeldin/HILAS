/**********************************************************
 * This file is generated by 20-sim C++ Code Generator
 *
 *  file:  src\BasePoseControllerModel.cpp
 *  subm:  BasePoseControllerModel
 *  model: motion_stack
 *  expmt: motion_stack
 *  date:  August 7, 2012
 *  time:  4:29:14 pm
 *  user:  Campuslicentie
 *  from:  Universiteit Twente
 *  build: 4.1.2.4
 **********************************************************/

/* Standard include files */
#include <stdio.h>
#include <math.h>
#include <stdexcept>

/* 20-sim include files */
#include "BasePoseControllerModel.hpp"

/* Orocos include */
#include <boost/algorithm/string.hpp>

using namespace std;

namespace motion_stack
{

	BasePoseControllerModel::BasePoseControllerModel(): m_model_config(this)
	{
		using namespace boost;

		setupComputation();
	}

	BasePoseControllerModel::~BasePoseControllerModel(void)
	{
		/* free memory */
		delete[] C;
		delete[] P;
		delete[] I;
		delete[] V;
		delete[] s;
		delete[] R;
		delete[] M;
		delete[] U;
		delete[] workarray;
	}

  void BasePoseControllerModel::setupComputation()
  {
    start_time = 0.0;
    finish_time = 0;
    step_size = 0.001;
    time = 0;
    major = true;

    number_constants = 0;
    number_parameters = 20;
    number_initialvalues = 10;
    number_variables = 267;
    number_states = 10;
    number_rates = 10;
    number_matrices = 69;
    number_unnamed = 236;

    /* the variable arrays */
    C = new XXDouble[0 + 1]; /* constants */
    P = new XXDouble[20 + 1]; /* parameters, currently only one type of parameter exists: double */
    I = new XXDouble[10 + 1]; /* initial values */
    V = new XXDouble[267 + 1]; /* variables */

    s = new XXDouble[10 + 1]; /* states */
    R = new XXDouble[10 + 1]; /* rates (or new states) */
    M = new XXMatrix[69 + 1]; /* matrices */
    U = new XXDouble[236 + 1]; /* unnamed */
    workarray = new XXDouble[42 + 1];
  }

	bool BasePoseControllerModel::loadModelConfiguration(std::string uri)
	{
	  m_model_config.load(uri);
	  return true;
	}

	XXModelConfiguration& BasePoseControllerModel::getModelConfiguration()
	{
	  return m_model_config;
	}

  bool BasePoseControllerModel::configure()
  {
    myintegmethod.Initialize(this);

    /* initialization phase (allocating memory) */
    initialize = true;
    //CONSTANTS
    

    //PARAMETERS
    	P[0] = 100.0;		/* BasePositionController\PD_BaseAngle\kp {} */
	P[1] = 1.0;		/* BasePositionController\PD_BaseAngle\tauD {s} */
	P[2] = 0.1;		/* BasePositionController\PD_BaseAngle\beta {} */
	P[3] = 100.0;		/* BasePositionController\PD_BaseX\kp {} */
	P[4] = 1.0;		/* BasePositionController\PD_BaseX\tauD {s} */
	P[5] = 0.1;		/* BasePositionController\PD_BaseX\beta {} */
	P[6] = 100.0;		/* BasePositionController\PD_BaseY\kp {} */
	P[7] = 1.0;		/* BasePositionController\PD_BaseY\tauD {s} */
	P[8] = 0.1;		/* BasePositionController\PD_BaseY\beta {} */
	P[9] = 0.0475;		/* BaseTF\r */
	P[10] = 0.235;		/* BaseTF\x */
	P[11] = 0.15;		/* BaseTF\y */
	P[12] = 0.0;		/* DiscreteDifferential\initial */
	P[13] = 0.0675;		/* FilterBaseJointVelocities1\FilterGain */
	P[14] = 0.1349;		
	P[15] = 0.0675;		
	P[16] = 1.143;		
	P[17] = -0.4128;		
	P[18] = 0.0;		
	P[19] = 4.0;		/* FilterBaseJointVelocities1\num */


    //INITIAL VALUES
    	I[0] = 0.0;		/* BasePositionController\PD_BaseAngle\uD_previous_initial */
	I[1] = 0.0;		/* BasePositionController\PD_BaseAngle\error_previous_initial */
	I[2] = 0.0;		/* BasePositionController\PD_BaseX\uD_previous_initial */
	I[3] = 0.0;		/* BasePositionController\PD_BaseX\error_previous_initial */
	I[4] = 0.0;		/* BasePositionController\PD_BaseY\uD_previous_initial */
	I[5] = 0.0;		/* BasePositionController\PD_BaseY\error_previous_initial */
	I[6] = 0.0;		/* DiscreteDifferential\input_previous_initial */
	I[7] = 0.0;		
	I[8] = 0.0;		
	I[9] = 0.0;		


    //MATRICES
    	M[0].mat = &V[0];		/* BasePositionController\dHToErrors\H_vp_base */
	M[0].rows = 4;
	M[0].columns = 4;
	M[1].mat = &V[18];		/* BasePositionController\dHToErrors\norm_omega */
	M[1].rows = 3;
	M[1].columns = 1;
	M[2].mat = &V[21];		/* BasePositionController\dHToErrors\omega */
	M[2].rows = 3;
	M[2].columns = 1;
	M[3].mat = &V[24];		/* BasePositionController\ErrorsToW\W_base_base0 */
	M[3].rows = 6;
	M[3].columns = 1;
	M[4].mat = &V[33];		/* BasePositionController\Submodel3\cmd */
	M[4].rows = 6;
	M[4].columns = 1;
	M[5].mat = &V[39];		/* BasePositionController\Submodel3\aldo */
	M[5].rows = 6;
	M[5].columns = 1;
	M[6].mat = &V[45];		/* BasePositionController\H_vp_0 */
	M[6].rows = 4;
	M[6].columns = 4;
	M[7].mat = &V[61];		/* BasePositionController\active_joint */
	M[7].rows = 3;
	M[7].columns = 1;
	M[8].mat = &V[64];		/* BaseTF\Twist */
	M[8].rows = 6;
	M[8].columns = 1;
	M[9].mat = &V[70];		/* BaseTF\Virtual_joint_states */
	M[9].rows = 3;
	M[9].columns = 1;
	M[10].mat = &V[73];		/* BaseTF\Base_torque */
	M[10].rows = 4;
	M[10].columns = 1;
	M[11].mat = &V[77];		/* BaseTF\A */
	M[11].rows = 3;
	M[11].columns = 4;
	M[12].mat = &V[89];		/* BaseTF\PseudoInverseA */
	M[12].rows = 4;
	M[12].columns = 3;
	M[13].mat = &V[101];		/* BaseTF\virtual_velocities */
	M[13].rows = 3;
	M[13].columns = 1;
	M[14].mat = &V[104];		/* DiscreteDifferential\output */
	M[14].rows = 4;
	M[14].columns = 1;
	M[15].mat = &V[108];		/* DiscreteDifferential\initial_input */
	M[15].rows = 4;
	M[15].columns = 1;
	M[16].mat = &V[113];		/* FilterBaseJointVelocities1\input */
	M[16].rows = 4;
	M[16].columns = 1;
	M[17].mat = &P[13];		/* FilterBaseJointVelocities1\FilterGain */
	M[17].rows = 2;
	M[17].columns = 3;
	M[18].mat = &V[117];		/* FilterBaseJointVelocities1\InputMemory */
	M[18].rows = 3;
	M[18].columns = 4;
	M[19].mat = &V[129];		/* FilterBaseJointVelocities1\InputUpdate */
	M[19].rows = 3;
	M[19].columns = 3;
	M[20].mat = &V[138];		/* FilterBaseJointVelocities1\State */
	M[20].rows = 3;
	M[20].columns = 4;
	M[21].mat = &V[150];		/* FilterBaseJointVelocities1\A */
	M[21].rows = 3;
	M[21].columns = 3;
	M[22].mat = &V[159];		/* FilterBaseJointVelocities1\B */
	M[22].rows = 3;
	M[22].columns = 3;
	M[23].mat = &V[168];		/* PlusMinus4\output */
	M[23].rows = 6;
	M[23].columns = 1;
	M[24].mat = &V[174];		/* PlusMinus4\plus2 */
	M[24].rows = 6;
	M[24].columns = 1;
	M[25].mat = &V[180];		/* Splitter5\input */
	M[25].rows = 4;
	M[25].columns = 4;
	M[26].mat = &V[196];		/* H_base_0_output */
	M[26].rows = 4;
	M[26].columns = 4;
	M[27].mat = &V[212];		/* T_base_00 */
	M[27].rows = 6;
	M[27].columns = 1;
	M[28].mat = &V[218];		/* Base_torque */
	M[28].rows = 4;
	M[28].columns = 1;
	M[29].mat = &V[222];		/* Base_wheels_angle */
	M[29].rows = 4;
	M[29].columns = 1;
	M[30].mat = &V[226];		/* H_base_0 */
	M[30].rows = 4;
	M[30].columns = 4;
	M[31].mat = &V[242];		/* W_base_00 */
	M[31].rows = 6;
	M[31].columns = 1;
	M[32].mat = &V[248];		/* H_vp_0 */
	M[32].rows = 4;
	M[32].columns = 4;
	M[33].mat = &V[264];		/* active_joint */
	M[33].rows = 3;
	M[33].columns = 1;
	M[34].mat = &R[6];		/* DiscreteDifferential\input */
	M[34].rows = 4;
	M[34].columns = 1;
	M[35].mat = &s[6];		/* DiscreteDifferential\input_previous */
	M[35].rows = 4;
	M[35].columns = 1;
	M[36].mat = &I[6];		/* DiscreteDifferential\input_previous_initial */
	M[36].rows = 4;
	M[36].columns = 1;
	M[37].mat = &U[0];		/* U1 */
	M[37].rows = 1;
	M[37].columns = 3;
	M[38].mat = &U[3];		/* U2 */
	M[38].rows = 2;
	M[38].columns = 3;
	M[39].mat = &U[9];		/* U3 */
	M[39].rows = 1;
	M[39].columns = 3;
	M[40].mat = &U[12];		/* U4 */
	M[40].rows = 3;
	M[40].columns = 4;
	M[41].mat = &U[24];		/* U5 */
	M[41].rows = 3;
	M[41].columns = 4;
	M[42].mat = &U[36];		/* U6 */
	M[42].rows = 3;
	M[42].columns = 1;
	M[43].mat = &U[39];		/* U7 */
	M[43].rows = 1;
	M[43].columns = 4;
	M[44].mat = &U[43];		/* U8 */
	M[44].rows = 3;
	M[44].columns = 4;
	M[45].mat = &U[55];		/* U9 */
	M[45].rows = 3;
	M[45].columns = 4;
	M[46].mat = &U[67];		/* U10 */
	M[46].rows = 1;
	M[46].columns = 4;
	M[47].mat = &U[71];		/* U11 */
	M[47].rows = 1;
	M[47].columns = 3;
	M[48].mat = &U[74];		/* U12 */
	M[48].rows = 1;
	M[48].columns = 1;
	M[49].mat = &U[75];		/* U13 */
	M[49].rows = 4;
	M[49].columns = 1;
	M[50].mat = &U[79];		/* U14 */
	M[50].rows = 1;
	M[50].columns = 1;
	M[51].mat = &U[80];		/* U15 */
	M[51].rows = 4;
	M[51].columns = 4;
	M[52].mat = &U[96];		/* U16 */
	M[52].rows = 1;
	M[52].columns = 1;
	M[53].mat = &U[97];		/* U17 */
	M[53].rows = 3;
	M[53].columns = 3;
	M[54].mat = &U[106];		/* U18 */
	M[54].rows = 1;
	M[54].columns = 1;
	M[55].mat = &U[107];		/* U19 */
	M[55].rows = 1;
	M[55].columns = 1;
	M[56].mat = &U[108];		/* U20 */
	M[56].rows = 3;
	M[56].columns = 1;
	M[57].mat = &U[111];		/* U21 */
	M[57].rows = 3;
	M[57].columns = 4;
	M[58].mat = &U[123];		/* U22 */
	M[58].rows = 4;
	M[58].columns = 3;
	M[59].mat = &U[135];		/* U23 */
	M[59].rows = 3;
	M[59].columns = 3;
	M[60].mat = &U[144];		/* U24 */
	M[60].rows = 3;
	M[60].columns = 3;
	M[61].mat = &U[153];		/* U25 */
	M[61].rows = 4;
	M[61].columns = 3;
	M[62].mat = &U[165];		/* U26 */
	M[62].rows = 3;
	M[62].columns = 1;
	M[63].mat = &U[168];		/* U27 */
	M[63].rows = 3;
	M[63].columns = 4;
	M[64].mat = &U[180];		/* U28 */
	M[64].rows = 4;
	M[64].columns = 1;
	M[65].mat = &U[184];		/* U29 */
	M[65].rows = 4;
	M[65].columns = 1;
	M[66].mat = &U[188];		/* U30 */
	M[66].rows = 6;
	M[66].columns = 6;
	M[67].mat = &U[224];		/* U31 */
	M[67].rows = 6;
	M[67].columns = 1;
	M[68].mat = &U[230];		/* U32 */
	M[68].rows = 6;
	M[68].columns = 1;


    //INITIALIZE_DEPSTATES
    //INITIALIZE_ALGLOOPS
    //INITIALIZE_CONSTRAINTS%

    //INPUTS
    //INITIALIZE_INPUTS% -> not the actual inputs

    //OUTPUTS
    //INITIALIZE_OUTPUTS% -> not the actual outputs

    //INITIALIZE_FAVORITE_PARS
    //INITIALIZE_FAVORITE_VARS

    //INITIALIZE_CONSTANTS%
    /* set the states */
    //INITIALIZE_STATES%

    /* set the matrices */
    //INITIALIZE_MATRICES%

    // overload INITIALIZE_* with values from xml
    std::vector<XVMatrix>& pps = m_model_config.getConfiguration();

    for(unsigned int i = 0; i < pps.size(); ++i)
    {
      if( static_cast<unsigned int>(pps[i].storage.rows * pps[i].storage.columns) != pps[i].values.size())
        throw std::out_of_range("" + pps[i].name);

      // Copy to XXData -> double*
      memcpy(pps[i].storage.mat, pps[i].values.data(), pps[i].values.size()*sizeof(double));
    }

    //STATES - do NOT move this line up!
    	s[0] = I[0];		/* BasePositionController\PD_BaseAngle\uD_previous */
	s[1] = I[1];		/* BasePositionController\PD_BaseAngle\error_previous */
	s[2] = I[2];		/* BasePositionController\PD_BaseX\uD_previous */
	s[3] = I[3];		/* BasePositionController\PD_BaseX\error_previous */
	s[4] = I[4];		/* BasePositionController\PD_BaseY\uD_previous */
	s[5] = I[5];		/* BasePositionController\PD_BaseY\error_previous */
	s[6] = I[6];		/* DiscreteDifferential\input_previous */
	s[7] = I[7];
	s[8] = I[8];
	s[9] = I[9];


    /* end of initialization phase */
    initialize = false;
    return initialize;
  }

  void BasePoseControllerModel::start()
  {
    /* calculate initial and static equations */
    CalculateInitial ();
    CalculateStatic ();
    CopyInputsToVariables ();
    CalculateInput ();
    CalculateDynamic();
    CalculateOutput ();
    CopyVariablesToOutputs ();
  }

  void BasePoseControllerModel::step()
  {
    /* another precessor submodel could determine the parameters of this submodel
         and therefore the static parameter calculations need to be performed. */
    CalculateStatic ();

    /* main calculation of the model */
    CopyInputsToVariables (); //get input from port
    CalculateInput ();
    myintegmethod.Step();
    CalculateOutput ();
    CopyVariablesToOutputs (); //send output to port
  }

  void BasePoseControllerModel::stop()
  {
    CopyInputsToVariables();
    /* calculate the final model equations */
    CalculateFinal ();
    CopyVariablesToOutputs();
  }

  XXDouble BasePoseControllerModel::getTime(void)
  {
    return time;
  }

	/* This function calculates the initial equations of the model.
	 * These equations are calculated before anything else
	 */
	inline void BasePoseControllerModel::CalculateInitial (void)
	{
				/* BaseTF\Twist = 0; */
		XXMatrixScalarMov (&M[8], 0.0);

		/* BaseTF\Virtual_joint_states = 0; */
		XXMatrixScalarMov (&M[9], 0.0);

		/* BaseTF\Base_torque = 0; */
		XXMatrixScalarMov (&M[10], 0.0);

		/* DiscreteDifferential\initialized = 0.0; */
		V[112] = XXFALSE;

		/* FilterBaseJointVelocities1\InputUpdate = [0, 0, 0; 1, 0, 0; 0, 1, 0]; */
		M[19].mat[0] = 0.0;
		M[19].mat[1] = 0.0;
		M[19].mat[2] = 0.0;
		M[19].mat[3] = 1.0;
		M[19].mat[4] = 0.0;
		M[19].mat[5] = 0.0;
		M[19].mat[6] = 0.0;
		M[19].mat[7] = 1.0;
		M[19].mat[8] = 0.0;

		/* FilterBaseJointVelocities1\InputMemory = 0; */
		XXMatrixScalarMov (&M[18], 0.0);

		/* FilterBaseJointVelocities1\State = 0; */
		XXMatrixScalarMov (&M[20], 0.0);

		/* FilterBaseJointVelocities1\A[1,:] = FilterBaseJointVelocities1\FilterGain[2,:]; */
		M[37].mat[0] = M[17].mat[3];
		M[37].mat[1] = M[17].mat[4];
		M[37].mat[2] = M[17].mat[5];
		M[21].mat[0] = M[37].mat[0];
		M[21].mat[1] = M[37].mat[1];
		M[21].mat[2] = M[37].mat[2];

		/* FilterBaseJointVelocities1\A[2:3,:] = [1, 0, 0; 0, 1, 0]; */
		M[38].mat[0] = 1.0;
		M[38].mat[1] = 0.0;
		M[38].mat[2] = 0.0;
		M[38].mat[3] = 0.0;
		M[38].mat[4] = 1.0;
		M[38].mat[5] = 0.0;
		M[21].mat[3] = M[38].mat[0];
		M[21].mat[4] = M[38].mat[1];
		M[21].mat[5] = M[38].mat[2];
		M[21].mat[6] = M[38].mat[3];
		M[21].mat[7] = M[38].mat[4];
		M[21].mat[8] = M[38].mat[5];

		/* FilterBaseJointVelocities1\B[1,:] = FilterBaseJointVelocities1\FilterGain[1,:]; */
		M[39].mat[0] = M[17].mat[0];
		M[39].mat[1] = M[17].mat[1];
		M[39].mat[2] = M[17].mat[2];
		M[22].mat[0] = M[39].mat[0];
		M[22].mat[1] = M[39].mat[1];
		M[22].mat[2] = M[39].mat[2];

		/* FilterBaseJointVelocities1\B[2:3,:] = 0; */
		M[22].mat[3] = 0.0;
		M[22].mat[4] = 0.0;
		M[22].mat[5] = 0.0;
		M[22].mat[6] = 0.0;
		M[22].mat[7] = 0.0;
		M[22].mat[8] = 0.0;

	}

	/* This function calculates the static equations of the model.
	 * These equations are only dependent from parameters and constants
	 */
	inline void BasePoseControllerModel::CalculateStatic (void)
	{
		
	}

	/* This function calculates the input equations of the model.
	 * These equations are dynamic equations that must not change
	 * in calls from the integration method (like random and delay).
	 */
	inline void BasePoseControllerModel::CalculateInput (void)
	{
		
	}

	/* This function calculates the dynamic equations of the model.
	 * These equations are called from the integration method
	 * to calculate the new model rates (that are then integrated).
	 */
	inline void BasePoseControllerModel::CalculateDynamic (void)
	{
			/* BasePositionController\PD_BaseAngle\factor = 1 / (sampletime + BasePositionController\PD_BaseAngle\tauD * BasePositionController\PD_BaseAngle\beta); */
	V[30] = 1.0 / (step_size + P[1] * P[2]);

	/* BasePositionController\PD_BaseX\factor = 1 / (sampletime + BasePositionController\PD_BaseX\tauD * BasePositionController\PD_BaseX\beta); */
	V[31] = 1.0 / (step_size + P[4] * P[5]);

	/* BasePositionController\PD_BaseY\factor = 1 / (sampletime + BasePositionController\PD_BaseY\tauD * BasePositionController\PD_BaseY\beta); */
	V[32] = 1.0 / (step_size + P[7] * P[8]);

	/* T_base_00 = BaseTF\Twist; */
	XXMatrixMov (&M[27], &M[8]);

	/* Base_torque = BaseTF\Base_torque; */
	XXMatrixMov (&M[28], &M[10]);

	/* Splitter5\input = H_base_0; */
	XXMatrixMov (&M[25], &M[30]);

		/* FilterBaseJointVelocities1\InputMemory = FilterBaseJointVelocities1\InputUpdate * FilterBaseJointVelocities1\InputMemory + [1; 0; 0] * transpose (FilterBaseJointVelocities1\input); */
		XXMatrixMul (&M[40], &M[19], &M[18]);
		M[42].mat[0] = 1.0;
		M[42].mat[1] = 0.0;
		M[42].mat[2] = 0.0;
		XXMatrixTranspose (&M[43], &M[16]);
		XXMatrixMul (&M[41], &M[42], &M[43]);
		XXMatrixAdd (&M[18], &M[40], &M[41]);

		/* FilterBaseJointVelocities1\State = FilterBaseJointVelocities1\A * FilterBaseJointVelocities1\State + FilterBaseJointVelocities1\B * FilterBaseJointVelocities1\InputMemory; */
		XXMatrixMul (&M[44], &M[21], &M[20]);
		XXMatrixMul (&M[45], &M[22], &M[18]);
		XXMatrixAdd (&M[20], &M[44], &M[45]);

		/* DiscreteDifferential\input = transpose ([1, 0, 0] * FilterBaseJointVelocities1\State); */
		M[47].mat[0] = 1.0;
		M[47].mat[1] = 0.0;
		M[47].mat[2] = 0.0;
		XXMatrixMul (&M[46], &M[47], &M[20]);
		XXMatrixTranspose (&M[34], &M[46]);

	/* if notDiscreteDifferential\initialized */
	if (!V[112])
	{
		/* DiscreteDifferential\initial_input = DiscreteDifferential\initial - DiscreteDifferential\input / sampletime; */
		XXMatrixScalarDiv (&M[49], &M[34], step_size);
		XXScalarMatrixSub (&M[15], P[12], &M[49]);

		/* DiscreteDifferential\initialized = 1.0; */
		V[112] = XXTRUE;
	}
	else
	{
		/* DiscreteDifferential\initial_input = 0; */
		XXMatrixScalarMov (&M[15], 0.0);
	}

	/* H_base_0_output = Splitter5\input; */
	XXMatrixMov (&M[26], &M[25]);

		/* BasePositionController\dHToErrors\H_vp_base = inverseH (BasePositionController\H_vp_0) * Splitter5\input; */
		XXMatrixInverseH (&M[51], &M[6]);
		XXMatrixMul (&M[0], &M[51], &M[25]);

		/* BasePositionController\dHToErrors\aldo = (trace (BasePositionController\dHToErrors\H_vp_base[1:3,1:3]) - 1) / 2; */
		M[53].mat[0] = M[0].mat[0];
		M[53].mat[1] = M[0].mat[1];
		M[53].mat[2] = M[0].mat[2];
		M[53].mat[3] = M[0].mat[4];
		M[53].mat[4] = M[0].mat[5];
		M[53].mat[5] = M[0].mat[6];
		M[53].mat[6] = M[0].mat[8];
		M[53].mat[7] = M[0].mat[9];
		M[53].mat[8] = M[0].mat[10];
		M[52].mat[0] = XXMatrixTrace (&M[53]);
		V[16] = (XXMatrixTrace (&M[53]) - 1.0) / 2.0;

		/* if (BasePositionController\dHToErrors\aldo < -1) */
		if (V[16] < -1.0)
		{
			/* BasePositionController\dHToErrors\aldo = -1; */
			V[16] = -1.0;
		}

		/* if (BasePositionController\dHToErrors\aldo > 1) */
		if (V[16] > 1.0)
		{
			/* BasePositionController\dHToErrors\aldo = 1; */
			V[16] = 1.0;
		}

		/* BasePositionController\dHToErrors\theta = arccos (BasePositionController\dHToErrors\aldo); */
		V[17] = acos (V[16]);

		/* if (BasePositionController\dHToErrors\theta == 0) */
		if (V[17] == 0.0)
		{
			/* BasePositionController\dHToErrors\norm_omega = 0; */
			XXMatrixScalarMov (&M[1], 0.0);
		}
		else
		{
			/* BasePositionController\dHToErrors\norm_omega = (1 / (2 * sin (BasePositionController\dHToErrors\theta))) * [BasePositionController\dHToErrors\H_vp_base[3,2] - BasePositionController\dHToErrors\H_vp_base[2,3]; BasePositionController\dHToErrors\H_vp_base[1,3] - BasePositionController\dHToErrors\H_vp_base[3,1]; BasePositionController\dHToErrors\H_vp_base[2,1] - BasePositionController\dHToErrors\H_vp_base[1,2]]; */
			M[56].mat[0] = M[0].mat[9] - M[0].mat[6];
			M[56].mat[1] = M[0].mat[2] - M[0].mat[8];
			M[56].mat[2] = M[0].mat[4] - M[0].mat[1];
			XXScalarMatrixMul (&M[1], (1.0 / (2.0 * sin (V[17]))), &M[56]);
		}

		/* BasePositionController\dHToErrors\omega = BasePositionController\dHToErrors\theta * BasePositionController\dHToErrors\norm_omega; */
		XXScalarMatrixMul (&M[2], V[17], &M[1]);

		/* BasePositionController\PD_BaseX\error = -BasePositionController\dHToErrors\H_vp_base[1,4]; */
		R[3] = -M[0].mat[3];

		/* BasePositionController\PD_BaseY\error = -BasePositionController\dHToErrors\H_vp_base[2,4]; */
		R[5] = -M[0].mat[7];

		/* BasePositionController\PD_BaseAngle\error = -BasePositionController\dHToErrors\omega[3]; */
		R[1] = -M[2].mat[2];

	/* BasePositionController\PD_BaseAngle\uD = BasePositionController\PD_BaseAngle\factor * (((BasePositionController\PD_BaseAngle\tauD * BasePositionController\PD_BaseAngle\uD_previous) * BasePositionController\PD_BaseAngle\beta + (BasePositionController\PD_BaseAngle\tauD * BasePositionController\PD_BaseAngle\kp) * (BasePositionController\PD_BaseAngle\error - BasePositionController\PD_BaseAngle\error_previous)) + (sampletime * BasePositionController\PD_BaseAngle\kp) * BasePositionController\PD_BaseAngle\error); */
	R[0] = V[30] * (((P[1] * s[0]) * P[2] + (P[1] * P[0]) * (R[1] - s[1])) + (step_size * P[0]) * R[1]);

	/* BasePositionController\PD_BaseX\uD = BasePositionController\PD_BaseX\factor * (((BasePositionController\PD_BaseX\tauD * BasePositionController\PD_BaseX\uD_previous) * BasePositionController\PD_BaseX\beta + (BasePositionController\PD_BaseX\tauD * BasePositionController\PD_BaseX\kp) * (BasePositionController\PD_BaseX\error - BasePositionController\PD_BaseX\error_previous)) + (sampletime * BasePositionController\PD_BaseX\kp) * BasePositionController\PD_BaseX\error); */
	R[2] = V[31] * (((P[4] * s[2]) * P[5] + (P[4] * P[3]) * (R[3] - s[3])) + (step_size * P[3]) * R[3]);

	/* BasePositionController\PD_BaseY\uD = BasePositionController\PD_BaseY\factor * (((BasePositionController\PD_BaseY\tauD * BasePositionController\PD_BaseY\uD_previous) * BasePositionController\PD_BaseY\beta + (BasePositionController\PD_BaseY\tauD * BasePositionController\PD_BaseY\kp) * (BasePositionController\PD_BaseY\error - BasePositionController\PD_BaseY\error_previous)) + (sampletime * BasePositionController\PD_BaseY\kp) * BasePositionController\PD_BaseY\error); */
	R[4] = V[32] * (((P[7] * s[4]) * P[8] + (P[7] * P[6]) * (R[5] - s[5])) + (step_size * P[6]) * R[5]);

		/* BaseTF\A = (1 / (BaseTF\r)) * [BaseTF\x + BaseTF\y, BaseTF\x + BaseTF\y, BaseTF\x + BaseTF\y, BaseTF\x + BaseTF\y; -1, 1, -1, 1; 1, 1, -1, -1]; */
		M[57].mat[0] = P[10] + P[11];
		M[57].mat[1] = P[10] + P[11];
		M[57].mat[2] = P[10] + P[11];
		M[57].mat[3] = P[10] + P[11];
		M[57].mat[4] = -1.0;
		M[57].mat[5] = 1.0;
		M[57].mat[6] = -1.0;
		M[57].mat[7] = 1.0;
		M[57].mat[8] = 1.0;
		M[57].mat[9] = 1.0;
		M[57].mat[10] = -1.0;
		M[57].mat[11] = -1.0;
		XXScalarMatrixMul (&M[11], (1.0 / (P[9])), &M[57]);

		/* BaseTF\PseudoInverseA = transpose (BaseTF\A) * inverse (BaseTF\A * transpose (BaseTF\A)); */
		XXMatrixTranspose (&M[58], &M[11]);
		XXMatrixTranspose (&M[61], &M[11]);
		XXMatrixMul (&M[60], &M[11], &M[61]);
		XXMatrixInverse (&M[59], &M[60], workarray);
		XXMatrixMul (&M[12], &M[58], &M[59]);

		/* BaseTF\Base_torque = BaseTF\PseudoInverseA * PlusMinus4\output[3:5]; */
		M[62].mat[0] = M[23].mat[2];
		M[62].mat[1] = M[23].mat[3];
		M[62].mat[2] = M[23].mat[4];
		XXMatrixMul (&M[10], &M[12], &M[62]);

		/* BaseTF\virtual_velocities = transpose (BaseTF\PseudoInverseA) * DiscreteDifferential\output; */
		XXMatrixTranspose (&M[63], &M[12]);
		XXMatrixMul (&M[13], &M[63], &M[14]);

		/* BaseTF\Twist = [0; 0; BaseTF\virtual_velocities[1]; BaseTF\virtual_velocities[2]; BaseTF\virtual_velocities[3]; 0]; */
		M[8].mat[0] = 0.0;
		M[8].mat[1] = 0.0;
		M[8].mat[2] = M[13].mat[0];
		M[8].mat[3] = M[13].mat[1];
		M[8].mat[4] = M[13].mat[2];
		M[8].mat[5] = 0.0;

		/* BaseTF\Virtual_joint_states[1] = atan2 (Splitter5\input[2,1], Splitter5\input[1,1]); */
		M[9].mat[0] = atan2 (M[25].mat[4], M[25].mat[0]);

		/* BaseTF\Virtual_joint_states[2] = Splitter5\input[1,4]; */
		M[9].mat[1] = M[25].mat[3];

		/* BaseTF\Virtual_joint_states[3] = Splitter5\input[2,4]; */
		M[9].mat[2] = M[25].mat[7];

	}

	/* This function calculates the output equations of the model.
	 * These equations are not needed for calculation of the rates
	 * and are kept separate to make the dynamic set of equations smaller.
	 * These dynamic equations are called often more than one time for each
	 * integration step that is taken. This makes model computation much faster.
	 */
	inline void BasePoseControllerModel::CalculateOutput (void)
	{
			/* FilterBaseJointVelocities1\input = Base_wheels_angle; */
	XXMatrixMov (&M[16], &M[29]);

	/* PlusMinus4\plus2 = W_base_00; */
	XXMatrixMov (&M[24], &M[31]);

	/* BasePositionController\H_vp_0 = H_vp_0; */
	XXMatrixMov (&M[6], &M[32]);

	/* BasePositionController\active_joint = active_joint; */
	XXMatrixMov (&M[7], &M[33]);

	/* BasePositionController\Submodel3\aldo = [1; 1; BasePositionController\active_joint[1]; BasePositionController\active_joint[2]; BasePositionController\active_joint[3]; 1]; */
	M[5].mat[0] = 1.0;
	M[5].mat[1] = 1.0;
	M[5].mat[2] = M[7].mat[0];
	M[5].mat[3] = M[7].mat[1];
	M[5].mat[4] = M[7].mat[2];
	M[5].mat[5] = 1.0;

	/* DiscreteDifferential\output = (DiscreteDifferential\input - DiscreteDifferential\input_previous) / sampletime + DiscreteDifferential\initial_input; */
	XXMatrixSub (&M[65], &M[34], &M[35]);
	XXMatrixScalarDiv (&M[64], &M[65], step_size);
	XXMatrixAdd (&M[14], &M[64], &M[15]);

	/* BasePositionController\ErrorsToW\W_base_base0 = [0; 0; BasePositionController\PD_BaseAngle\uD; BasePositionController\PD_BaseX\uD; BasePositionController\PD_BaseY\uD; 0]; */
	M[3].mat[0] = 0.0;
	M[3].mat[1] = 0.0;
	M[3].mat[2] = R[0];
	M[3].mat[3] = R[2];
	M[3].mat[4] = R[4];
	M[3].mat[5] = 0.0;

	/* BasePositionController\Submodel3\cmd = diag (abs (sign (BasePositionController\Submodel3\aldo))) * BasePositionController\ErrorsToW\W_base_base0; */
	M[68].mat[0] = XXSign (M[5].mat[0]);
	M[68].mat[1] = XXSign (M[5].mat[1]);
	M[68].mat[2] = XXSign (M[5].mat[2]);
	M[68].mat[3] = XXSign (M[5].mat[3]);
	M[68].mat[4] = XXSign (M[5].mat[4]);
	M[68].mat[5] = XXSign (M[5].mat[5]);
	M[67].mat[0] = XXAbsolute (M[68].mat[0]);
	M[67].mat[1] = XXAbsolute (M[68].mat[1]);
	M[67].mat[2] = XXAbsolute (M[68].mat[2]);
	M[67].mat[3] = XXAbsolute (M[68].mat[3]);
	M[67].mat[4] = XXAbsolute (M[68].mat[4]);
	M[67].mat[5] = XXAbsolute (M[68].mat[5]);
	XXMatrixDiag (&M[66], &M[67]);
	XXMatrixMul (&M[4], &M[66], &M[3]);

	/* PlusMinus4\output = BasePositionController\Submodel3\cmd + PlusMinus4\plus2; */
	XXMatrixAdd (&M[23], &M[4], &M[24]);

			}

	/* This function calculates the final equations of the model.
	 * These equations are calculated after all the calculations
	 * are performed
	 */
	inline void BasePoseControllerModel::CalculateFinal (void)
	{
		
	}

	bool BasePoseControllerModel::setPeriod(double seconds)
	{
			step_size = seconds;
			return true;
	}

	double BasePoseControllerModel::getPeriod()
  {
      return step_size;
  }

}

